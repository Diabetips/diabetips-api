diff --git a/node_modules/class-validator/bundles/index.esm.js b/node_modules/class-validator/bundles/index.esm.js
index df913e1..bd16a5b 100644
--- a/node_modules/class-validator/bundles/index.esm.js
+++ b/node_modules/class-validator/bundles/index.esm.js
@@ -318,7 +318,7 @@ class ValidationExecutor {
             validationError.value = undefined;
             validationError.property = undefined;
             validationError.children = [];
-            validationError.constraints = { unknownValue: "an unknown value was passed to the validate function" };
+            validationError.constraints = ["an unknown value was passed to the validate function"];
             validationErrors.push(validationError);
             return;
         }
@@ -351,7 +351,7 @@ class ValidationExecutor {
                 // throw errors
                 notAllowedProperties.forEach(property => {
                     const validationError = this.generateValidationError(object, object[property], property);
-                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };
+                    validationError.constraints = [`property ${property} should not exist`];
                     validationError.children = undefined;
                     validationErrors.push(validationError);
                 });
@@ -367,7 +367,7 @@ class ValidationExecutor {
             if (error.children) {
                 error.children = this.stripEmptyErrors(error.children);
             }
-            if (Object.keys(error.constraints).length === 0) {
+            if (error.constraints.length === 0) {
                 if (error.children.length === 0) {
                     return false;
                 }
@@ -393,7 +393,6 @@ class ValidationExecutor {
         }
         // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not
         this.customValidations(object, value, definedMetadatas, validationError);
-        this.mapContexts(object, value, definedMetadatas, validationError);
         if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {
             return;
         }
@@ -405,8 +404,6 @@ class ValidationExecutor {
         }
         this.customValidations(object, value, customValidationMetadatas, validationError);
         this.nestedValidations(value, nestedValidationMetadatas, validationError.children);
-        this.mapContexts(object, value, metadatas, validationError);
-        this.mapContexts(object, value, customValidationMetadatas, validationError);
     }
     generateValidationError(object, value, propertyName) {
         const validationError = new ValidationError();
@@ -422,7 +419,7 @@ class ValidationExecutor {
             validationError.value = value;
         validationError.property = propertyName;
         validationError.children = [];
-        validationError.constraints = {};
+        validationError.constraints = [];
         return validationError;
     }
     conditionalValidations(object, value, metadatas) {
@@ -450,7 +447,7 @@ class ValidationExecutor {
                         const promise = validatedValue.then(isValid => {
                             if (!isValid) {
                                 const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
-                                error.constraints[type] = message;
+                                error.constraints.push(message);
                                 if (metadata.context) {
                                     if (!error.contexts) {
                                         error.contexts = {};
@@ -464,7 +461,7 @@ class ValidationExecutor {
                     else {
                         if (!validatedValue) {
                             const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
-                            error.constraints[type] = message;
+                            error.constraints.push(message);
                         }
                     }
                     return;
@@ -484,7 +481,7 @@ class ValidationExecutor {
                         const validationResult = flatValidatedValues.every((isValid) => isValid);
                         if (!validationResult) {
                             const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
-                            error.constraints[type] = message;
+                            error.constraints.push(message);
                             if (metadata.context) {
                                 if (!error.contexts) {
                                     error.contexts = {};
@@ -499,7 +496,7 @@ class ValidationExecutor {
                 const validationResult = validatedSubValues.every((isValid) => isValid);
                 if (!validationResult) {
                     const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
-                    error.constraints[type] = message;
+                    error.constraints.push(message);
                 }
             });
         });
@@ -530,32 +527,11 @@ class ValidationExecutor {
                 error.property = metadata.propertyName;
                 error.target = metadata.target;
                 const [type, message] = this.createValidationError(metadata.target, value, metadata);
-                error.constraints = {
-                    [type]: message
-                };
+                error.constraints = [message];
                 errors.push(error);
             }
         });
     }
-    mapContexts(object, value, metadatas, error) {
-        return metadatas
-            .forEach(metadata => {
-            if (metadata.context) {
-                let customConstraint;
-                if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {
-                    const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);
-                    customConstraint = customConstraints[0];
-                }
-                const type = this.getConstraintType(metadata, customConstraint);
-                if (error.constraints[type]) {
-                    if (!error.contexts) {
-                        error.contexts = {};
-                    }
-                    error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);
-                }
-            }
-        });
-    }
     createValidationError(object, value, metadata, customValidatorMetadata) {
         const targetName = object.constructor ? object.constructor.name : undefined;
         const type = this.getConstraintType(metadata, customValidatorMetadata);
diff --git a/node_modules/class-validator/bundles/index.esm.js.map b/node_modules/class-validator/bundles/index.esm.js.map
index 23385d2..4230419 100644
--- a/node_modules/class-validator/bundles/index.esm.js.map
+++ b/node_modules/class-validator/bundles/index.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.esm.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/validation/ValidationUtils.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/decorator/common/Allow.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["ValidatorJS"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.esm.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/validation/ValidationUtils.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/decorator/common/Allow.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: string[];\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = [\"an unknown value was passed to the validate function\"];\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = [`property ${property} should not exist`];\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (error.constraints.length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = [];\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints.push(message);\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints.push(message);\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = [message];\n                errors.push(error);\n            }\n        });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["ValidatorJS"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/class-validator/bundles/index.esm.min.js b/node_modules/class-validator/bundles/index.esm.min.js
index c92814e..add0f94 100644
--- a/node_modules/class-validator/bundles/index.esm.min.js
+++ b/node_modules/class-validator/bundles/index.esm.min.js
@@ -1,2 +1,2 @@
-import t from"validator";import{PhoneNumberUtil as n}from"google-libphonenumber";class e{constructor(t){this.groups=[],this.always=!1,this.each=!1,this.context=void 0,this.type=t.type,this.target=t.target,this.propertyName=t.propertyName,this.constraints=t.constraints,this.constraintCls=t.constraintCls,this.validationTypeOptions=t.validationTypeOptions,t.validationOptions&&(this.message=t.validationOptions.message,this.groups=t.validationOptions.groups,this.always=t.validationOptions.always,this.each=t.validationOptions.each,this.context=t.validationOptions.context)}}class a{transform(t){const n=[];return Object.keys(t.properties).forEach(a=>{t.properties[a].forEach(r=>{const i={message:r.message,groups:r.groups,always:r.always,each:r.each},s={type:r.type,target:t.name,propertyName:a,constraints:r.constraints,validationTypeOptions:r.options,validationOptions:i};n.push(new e(s))})}),n}}function r(){return"undefined"!=typeof window&&(window.global=window),global.classValidatorMetadataStorage||(global.classValidatorMetadataStorage=new i),global.classValidatorMetadataStorage}class i{constructor(){this.validationMetadatas=[],this.constraintMetadatas=[]}get hasValidationMetaData(){return!!this.validationMetadatas.length}addValidationSchema(t){(new a).transform(t).forEach(t=>this.addValidationMetadata(t))}addValidationMetadata(t){this.validationMetadatas.push(t)}addConstraintMetadata(t){this.constraintMetadatas.push(t)}groupByPropertyName(t){const n={};return t.forEach(t=>{n[t.propertyName]||(n[t.propertyName]=[]),n[t.propertyName].push(t)}),n}getTargetValidationMetadatas(t,n,e){const a=this.validationMetadatas.filter(a=>(a.target===t||a.target===n)&&(!!a.always||(!(e&&e.length>0)||a.groups&&!!a.groups.find(t=>-1!==e.indexOf(t))))),r=this.validationMetadatas.filter(n=>"string"!=typeof n.target&&(n.target!==t&&((!(n.target instanceof Function)||t.prototype instanceof n.target)&&(!!n.always||(!(e&&e.length>0)||n.groups&&!!n.groups.find(t=>-1!==e.indexOf(t))))))).filter(t=>!a.find(n=>n.propertyName===t.propertyName&&n.type===t.type));return a.concat(r)}getTargetValidatorConstraints(t){return this.constraintMetadatas.filter(n=>n.target===t)}}class s{toString(t=!1,n=!1,e=""){const a=t?"[1m":"",r=t?"[22m":"",i=t=>` - property ${a}${e}${t}${r} has failed the following constraints: ${a}${Object.keys(this.constraints).join(", ")}${r} \n`;if(n){const n=Number.isInteger(+this.property)?`[${this.property}]`:`${e?".":""}${this.property}`;return this.constraints?i(n):this.children.map(a=>a.toString(t,!0,`${e}${n}`)).join("")}return`An instance of ${a}${this.target?this.target.constructor.name:"an object"}${r} has failed the validation:\n`+(this.constraints?i(this.property):"")+this.children.map(n=>n.toString(t,!0,this.property)).join("")}}class o{static isValid(t){return"isValid"!==t&&"getMessage"!==t&&-1!==Object.keys(this).map(t=>this[t]).indexOf(t)}}o.CUSTOM_VALIDATION="customValidation",o.NESTED_VALIDATION="nestedValidation",o.PROMISE_VALIDATION="promiseValidation",o.CONDITIONAL_VALIDATION="conditionalValidation",o.WHITELIST="whitelistValidation",o.IS_DEFINED="isDefined";function c(t){return null!==t&&"object"==typeof t&&"function"==typeof t.then}class u{constructor(t,n){this.validator=t,this.validatorOptions=n,this.awaitingPromises=[],this.ignoreAsyncValidations=!1,this.metadataStorage=r()}execute(t,n,e){this.metadataStorage.hasValidationMetaData||console.warn("No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.");const a=this.validatorOptions?this.validatorOptions.groups:void 0,r=this.metadataStorage.getTargetValidationMetadatas(t.constructor,n,a),i=this.metadataStorage.groupByPropertyName(r);if(this.validatorOptions&&this.validatorOptions.forbidUnknownValues&&!r.length){const n=new s;return this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.target&&!0!==this.validatorOptions.validationError.target||(n.target=t),n.value=void 0,n.property=void 0,n.children=[],n.constraints={unknownValue:"an unknown value was passed to the validate function"},void e.push(n)}this.validatorOptions&&this.validatorOptions.whitelist&&this.whitelist(t,i,e),Object.keys(i).forEach(n=>{const a=t[n],r=i[n].filter(t=>t.type===o.IS_DEFINED),s=i[n].filter(t=>t.type!==o.IS_DEFINED&&t.type!==o.WHITELIST);a instanceof Promise&&s.find(t=>t.type===o.PROMISE_VALIDATION)?this.awaitingPromises.push(a.then(a=>{this.performValidations(t,a,n,r,s,e)})):this.performValidations(t,a,n,r,s,e)})}whitelist(t,n,e){let a=[];Object.keys(t).forEach(t=>{n[t]&&0!==n[t].length||a.push(t)}),a.length>0&&(this.validatorOptions&&this.validatorOptions.forbidNonWhitelisted?a.forEach(n=>{const a=this.generateValidationError(t,t[n],n);a.constraints={[o.WHITELIST]:`property ${n} should not exist`},a.children=void 0,e.push(a)}):a.forEach(n=>delete t[n]))}stripEmptyErrors(t){return t.filter(t=>{if(t.children&&(t.children=this.stripEmptyErrors(t.children)),0===Object.keys(t.constraints).length){if(0===t.children.length)return!1;delete t.constraints}return!0})}performValidations(t,n,e,a,r,i){const s=r.filter(t=>t.type===o.CUSTOM_VALIDATION),c=r.filter(t=>t.type===o.NESTED_VALIDATION),u=r.filter(t=>t.type===o.CONDITIONAL_VALIDATION),l=this.generateValidationError(t,n,e);i.push(l),this.conditionalValidations(t,n,u)&&(this.customValidations(t,n,a,l),this.mapContexts(t,n,a,l),void 0===n&&this.validatorOptions&&!0===this.validatorOptions.skipUndefinedProperties||null===n&&this.validatorOptions&&!0===this.validatorOptions.skipNullProperties||null==n&&this.validatorOptions&&!0===this.validatorOptions.skipMissingProperties||(this.customValidations(t,n,s,l),this.nestedValidations(n,c,l.children),this.mapContexts(t,n,r,l),this.mapContexts(t,n,s,l)))}generateValidationError(t,n,e){const a=new s;return this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.target&&!0!==this.validatorOptions.validationError.target||(a.target=t),this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.value&&!0!==this.validatorOptions.validationError.value||(a.value=n),a.property=e,a.children=[],a.constraints={},a}conditionalValidations(t,n,e){return e.map(e=>e.constraints[0](t,n)).reduce((t,n)=>t&&n,!0)}customValidations(t,n,e,a){e.forEach(e=>{this.metadataStorage.getTargetValidatorConstraints(e.constraintCls).forEach(r=>{if(r.async&&this.ignoreAsyncValidations)return;const i={targetName:t.constructor?t.constructor.name:void 0,property:e.propertyName,object:t,value:n,constraints:e.constraints};if(!e.each||!(n instanceof Array||n instanceof Set||n instanceof Map)){const s=r.instance.validate(n,i);if(c(s)){const i=s.then(i=>{if(!i){const[i,s]=this.createValidationError(t,n,e,r);a.constraints[i]=s,e.context&&(a.contexts||(a.contexts={}),a.contexts[i]=Object.assign(a.contexts[i]||{},e.context))}});this.awaitingPromises.push(i)}else if(!s){const[i,s]=this.createValidationError(t,n,e,r);a.constraints[i]=s}return}var s;const o=((s=n)instanceof Map?Array.from(s.values()):Array.isArray(s)?s:Array.from(s)).map(t=>r.instance.validate(t,i));if(o.some(t=>c(t))){const i=o.map(t=>c(t)?t:Promise.resolve(t)),s=Promise.all(i).then(i=>{if(!i.every(t=>t)){const[i,s]=this.createValidationError(t,n,e,r);a.constraints[i]=s,e.context&&(a.contexts||(a.contexts={}),a.contexts[i]=Object.assign(a.contexts[i]||{},e.context))}});this.awaitingPromises.push(s)}else if(!o.every(t=>t)){const[i,s]=this.createValidationError(t,n,e,r);a.constraints[i]=s}})})}nestedValidations(t,n,e){void 0!==t&&n.forEach(a=>{if(a.type===o.NESTED_VALIDATION||a.type===o.PROMISE_VALIDATION)if(t instanceof Array||t instanceof Set||t instanceof Map){(t instanceof Set?Array.from(t):t).forEach((a,r)=>{this.performValidations(t,a,r.toString(),[],n,e)})}else if(t instanceof Object){const n="string"==typeof a.target?a.target:a.target.name;this.execute(t,n,e)}else{const n=new s;n.value=t,n.property=a.propertyName,n.target=a.target;const[r,i]=this.createValidationError(a.target,t,a);n.constraints={[r]:i},e.push(n)}})}mapContexts(t,n,e,a){return e.forEach(t=>{if(t.context){let n;if(t.type===o.CUSTOM_VALIDATION){n=this.metadataStorage.getTargetValidatorConstraints(t.constraintCls)[0]}const e=this.getConstraintType(t,n);a.constraints[e]&&(a.contexts||(a.contexts={}),a.contexts[e]=Object.assign(a.contexts[e]||{},t.context))}})}createValidationError(t,n,e,a){const r=t.constructor?t.constructor.name:void 0,i=this.getConstraintType(e,a),s={targetName:r,property:e.propertyName,object:t,value:n,constraints:e.constraints};let o=e.message||"";return e.message||this.validatorOptions&&(!this.validatorOptions||this.validatorOptions.dismissDefaultMessages)||a&&a.instance.defaultMessage instanceof Function&&(o=a.instance.defaultMessage(s)),[i,class{static replaceMessageSpecialTokens(t,n){let e;return t instanceof Function?e=t(n):"string"==typeof t&&(e=t),e&&n.constraints instanceof Array&&n.constraints.forEach((t,n)=>{e=e.replace(new RegExp(`\\$constraint${n+1}`,"g"),t)}),e&&void 0!==n.value&&null!==n.value&&"string"==typeof n.value&&(e=e.replace(/\$value/g,n.value)),e&&(e=e.replace(/\$property/g,n.property)),e&&(e=e.replace(/\$target/g,n.targetName)),e}}.replaceMessageSpecialTokens(o,s)]}getConstraintType(t,n){return n&&n.name?n.name:t.type}}class l{coreValidate(t,n,e){const a="string"==typeof t?n:t,r="string"==typeof t?t:void 0,i=new u(this,"string"==typeof t?e:n),s=[];return i.execute(a,r,s),Promise.all(i.awaitingPromises).then(()=>i.stripEmptyErrors(s))}validate(t,n,e){return this.coreValidate(t,n,e)}async validateOrReject(t,n,e){const a=await this.coreValidate(t,n,e);if(a.length)return Promise.reject(a)}validateSync(t,n,e){const a="string"==typeof t?n:t,r="string"==typeof t?t:void 0,i=new u(this,"string"==typeof t?e:n);i.ignoreAsyncValidations=!0;const s=[];return i.execute(a,r,s),i.stripEmptyErrors(s)}}const d=new class{constructor(){this.instances=[]}get(t){let n=this.instances.find(n=>n.type===t);return n||(n={type:t,object:new t},this.instances.push(n)),n.object}};let p,f;function m(t,n){p=t,f=n}function g(t){if(p)try{const n=p.get(t);if(n)return n;if(!f||!f.fallback)return n}catch(t){if(!f||!f.fallbackOnErrors)throw t}return d.get(t)}function y(t){return function(n,a){const i={type:o.WHITELIST,target:n.constructor,propertyName:a,validationOptions:t};r().addValidationMetadata(new e(i))}}class v{constructor(t,n,e=!1){this.target=t,this.name=n,this.async=e}get instance(){return g(this.target)}}function h(t){let n;if(t.validator instanceof Function){if(n=t.validator,g(i).getTargetValidatorConstraints(t.validator).length>1)throw`More than one implementation of ValidatorConstraintInterface found for validator on: ${t.target}:${t.propertyName}`}else{const e=t.validator;n=class{validate(t,n){return e.validate(t,n)}defaultMessage(t){return e.defaultMessage?e.defaultMessage(t):""}},r().addConstraintMetadata(new v(n,t.name,t.async))}const a={type:t.name&&o.isValid(t.name)?t.name:o.CUSTOM_VALIDATION,target:t.target,propertyName:t.propertyName,validationOptions:t.options,constraintCls:n,constraints:t.constraints};r().addValidationMetadata(new e(a))}function b(t,n){return e=>{const a=n&&n.each?"each value in ":"";return t(a,e)}}function M(t,n){return function(e,a){h({name:t.name,target:e.constructor,propertyName:a,options:n,constraints:t.constraints,validator:t.validator})}}const $=o.IS_DEFINED;function I(t){return null!=t}function O(t){return M({name:$,validator:{validate:t=>I(t),defaultMessage:b(t=>t+"$property should not be null or undefined",t)}},t)}function N(t){return function(n,a){const i={type:o.CONDITIONAL_VALIDATION,target:n.constructor,propertyName:a,constraints:[(t,n)=>null!==t[a]&&void 0!==t[a]],validationOptions:t};r().addValidationMetadata(new e(i))}}function A(t){return function(n){const e=!(!t||!t.async);let a=t&&t.name?t.name:"";a||(a=n.name,a||(a=a.replace(/\.?([A-Z]+)/g,(t,n)=>"_"+n.toLowerCase()).replace(/^_/,"")));const i=new v(n,a,e);r().addConstraintMetadata(i)}}function S(t,n,a){return function(i,s){const c={type:o.CUSTOM_VALIDATION,target:i.constructor,propertyName:s,constraintCls:t,constraints:n instanceof Array?n:void 0,validationOptions:n instanceof Array?a:n};r().addValidationMetadata(new e(c))}}function E(t,n){return function(a,i){const s={type:o.CONDITIONAL_VALIDATION,target:a.constructor,propertyName:i,constraints:[t],validationOptions:n};r().addValidationMetadata(new e(s))}}function V(t){const n={...t},a=n.each?"each value in ":"";return n.message=n.message||a+"nested property $property must be either object or array",function(t,a){const i={type:o.NESTED_VALIDATION,target:t.constructor,propertyName:a,validationOptions:n};r().addValidationMetadata(new e(i))}}function C(t){return function(n,a){const i={type:o.PROMISE_VALIDATION,target:n.constructor,propertyName:a,validationOptions:t};r().addValidationMetadata(new e(i))}}const w="isLatLong";function T(n){return"string"==typeof n&&t.isLatLong(n)}function x(t){return M({name:"isLatLong",validator:{validate:(t,n)=>T(t),defaultMessage:b(t=>t+"$property must be a latitude,longitude string",t)}},t)}const D="isLatitude";function L(t){return("number"==typeof t||"string"==typeof t)&&T(`${t},0`)}function P(t){return M({name:"isLatitude",validator:{validate:(t,n)=>L(t),defaultMessage:b(t=>t+"$property must be a latitude string or number",t)}},t)}const j="isLongitude";function B(t){return("number"==typeof t||"string"==typeof t)&&T(`0,${t}`)}function R(t){return M({name:"isLongitude",validator:{validate:(t,n)=>B(t),defaultMessage:b(t=>t+"$property must be a longitude string or number",t)}},t)}const U="equals";function _(t,n){return t===n}function F(t,n){return M({name:"equals",constraints:[t],validator:{validate:(t,n)=>_(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be equal to $constraint1",n)}},n)}const H="notEquals";function k(t,n){return t!==n}function q(t,n){return M({name:"notEquals",constraints:[t],validator:{validate:(t,n)=>k(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not be equal to $constraint1",n)}},n)}const W="isEmpty";function z(t){return""===t||null==t}function J(t){return M({name:"isEmpty",validator:{validate:(t,n)=>z(t),defaultMessage:b(t=>t+"$property must be empty",t)}},t)}const Z="isNotEmpty";function G(t){return""!==t&&null!=t}function K(t){return M({name:"isNotEmpty",validator:{validate:(t,n)=>G(t),defaultMessage:b(t=>t+"$property should not be empty",t)}},t)}const Q="isIn";function Y(t,n){return!(n instanceof Array)||n.some(n=>n===t)}function X(t,n){return M({name:"isIn",constraints:[t],validator:{validate:(t,n)=>Y(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be one of the following values: $constraint1",n)}},n)}const tt="isNotIn";function nt(t,n){return!(n instanceof Array&&n.some(n=>n===t))}function et(t,n){return M({name:"isNotIn",constraints:[t],validator:{validate:(t,n)=>nt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not be one of the following values: $constraint1",n)}},n)}const at="isDivisibleBy";function rt(n,e){return"number"==typeof n&&"number"==typeof e&&t.isDivisibleBy(String(n),e)}function it(t,n){return M({name:"isDivisibleBy",constraints:[t],validator:{validate:(t,n)=>rt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be divisible by $constraint1",n)}},n)}const st="isPositive";function ot(t){return"number"==typeof t&&t>0}function ct(t){return M({name:"isPositive",validator:{validate:(t,n)=>ot(t),defaultMessage:b(t=>t+"$property must be a positive number",t)}},t)}const ut="isNegative";function lt(t){return"number"==typeof t&&t<0}function dt(t){return M({name:"isNegative",validator:{validate:(t,n)=>lt(t),defaultMessage:b(t=>t+"$property must be a negative number",t)}},t)}const pt="max";function ft(t,n){return"number"==typeof t&&"number"==typeof n&&t<=n}function mt(t,n){return M({name:"max",constraints:[t],validator:{validate:(t,n)=>ft(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must not be greater than $constraint1",n)}},n)}const gt="min";function yt(t,n){return"number"==typeof t&&"number"==typeof n&&t>=n}function vt(t,n){return M({name:"min",constraints:[t],validator:{validate:(t,n)=>yt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must not be less than $constraint1",n)}},n)}const ht="minDate";function bt(t,n){return t instanceof Date&&t.getTime()>=n.getTime()}function Mt(t,n){return M({name:"minDate",constraints:[t],validator:{validate:(t,n)=>bt(t,n.constraints[0]),defaultMessage:b(t=>"minimal allowed date for "+t+"$property is $constraint1",n)}},n)}const $t="maxDate";function It(t,n){return t instanceof Date&&t.getTime()<=n.getTime()}function Ot(t,n){return M({name:"maxDate",constraints:[t],validator:{validate:(t,n)=>It(t,n.constraints[0]),defaultMessage:b(t=>"maximal allowed date for "+t+"$property is $constraint1",n)}},n)}const Nt="contains";function At(n,e){return"string"==typeof n&&t.contains(n,e)}function St(t,n){return M({name:"contains",constraints:[t],validator:{validate:(t,n)=>At(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain a $constraint1 string",n)}},n)}const Et="notContains";function Vt(n,e){return"string"==typeof n&&!t.contains(n,e)}function Ct(t,n){return M({name:"notContains",constraints:[t],validator:{validate:(t,n)=>Vt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not contain a $constraint1 string",n)}},n)}const wt="isAlpha";function Tt(n,e){return"string"==typeof n&&t.isAlpha(n,e)}function xt(t,n){return M({name:"isAlpha",constraints:[t],validator:{validate:(t,n)=>Tt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain only letters (a-zA-Z)",n)}},n)}const Dt="isAlphanumeric";function Lt(n,e){return"string"==typeof n&&t.isAlphanumeric(n,e)}function Pt(t,n){return M({name:"isAlphanumeric",constraints:[t],validator:{validate:(t,n)=>Lt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain only letters and numbers",n)}},n)}const jt="isDecimal";function Bt(n,e){return"string"==typeof n&&t.isDecimal(n,e)}function Rt(t,n){return M({name:"isDecimal",constraints:[t],validator:{validate:(t,n)=>Bt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property is not a valid decimal number.",n)}},n)}const Ut="isAscii";function _t(n){return"string"==typeof n&&t.isAscii(n)}function Ft(t){return M({name:"isAscii",validator:{validate:(t,n)=>_t(t),defaultMessage:b(t=>t+"$property must contain only ASCII characters",t)}},t)}const Ht="isBase64";function kt(n){return"string"==typeof n&&t.isBase64(n)}function qt(t){return M({name:"isBase64",validator:{validate:(t,n)=>kt(t),defaultMessage:b(t=>t+"$property must be base64 encoded",t)}},t)}const Wt="isByteLength";function zt(n,e,a){return"string"==typeof n&&t.isByteLength(n,{min:e,max:a})}function Jt(t,n,e){return M({name:"isByteLength",constraints:[t,n],validator:{validate:(t,n)=>zt(t,n.constraints[0],n.constraints[1]),defaultMessage:b(t=>t+"$property's byte length must fall into ($constraint1, $constraint2) range",e)}},e)}const Zt="isCreditCard";function Gt(n){return"string"==typeof n&&t.isCreditCard(n)}function Kt(t){return M({name:"isCreditCard",validator:{validate:(t,n)=>Gt(t),defaultMessage:b(t=>t+"$property must be a credit card",t)}},t)}const Qt="isCurrency";function Yt(n,e){return"string"==typeof n&&t.isCurrency(n,e)}function Xt(t,n){return M({name:"isCurrency",constraints:[t],validator:{validate:(t,n)=>Yt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a currency",n)}},n)}const tn="isEmail";function nn(n,e){return"string"==typeof n&&t.isEmail(n,e)}function en(t,n){return M({name:"isEmail",constraints:[t],validator:{validate:(t,n)=>nn(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an email",n)}},n)}const an="isFqdn";function rn(n,e){return"string"==typeof n&&t.isFQDN(n,e)}function sn(t,n){return M({name:"isFqdn",constraints:[t],validator:{validate:(t,n)=>rn(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid domain name",n)}},n)}const on="isFullWidth";function cn(n){return"string"==typeof n&&t.isFullWidth(n)}function un(t){return M({name:"isFullWidth",validator:{validate:(t,n)=>cn(t),defaultMessage:b(t=>t+"$property must contain a full-width characters",t)}},t)}const ln="isHalfWidth";function dn(n){return"string"==typeof n&&t.isHalfWidth(n)}function pn(t){return M({name:"isHalfWidth",validator:{validate:(t,n)=>dn(t),defaultMessage:b(t=>t+"$property must contain a half-width characters",t)}},t)}const fn="isVariableWidth";function mn(n){return"string"==typeof n&&t.isVariableWidth(n)}function gn(t){return M({name:"isVariableWidth",validator:{validate:(t,n)=>mn(t),defaultMessage:b(t=>t+"$property must contain a full-width and half-width characters",t)}},t)}const yn="isHexColor";function vn(n){return"string"==typeof n&&t.isHexColor(n)}function hn(t){return M({name:"isHexColor",validator:{validate:(t,n)=>vn(t),defaultMessage:b(t=>t+"$property must be a hexadecimal color",t)}},t)}const bn="isHexadecimal";function Mn(n){return"string"==typeof n&&t.isHexadecimal(n)}function $n(t){return M({name:"isHexadecimal",validator:{validate:(t,n)=>Mn(t),defaultMessage:b(t=>t+"$property must be a hexadecimal number",t)}},t)}function In(t){return!!t&&("each"in t||"message"in t||"groups"in t||"always"in t||"context"in t)}const On="isMacAddress";function Nn(n,e){return"string"==typeof n&&t.isMACAddress(n,e)}function An(t,n){const e=In(t)?void 0:t,a=In(t)?t:n;return M({name:"isMacAddress",constraints:[e],validator:{validate:(t,n)=>Nn(t,e),defaultMessage:b(t=>t+"$property must be a MAC Address",a)}},a)}const Sn="isIp";function En(n,e){const a=e?`${e}`:void 0;return"string"==typeof n&&t.isIP(n,a)}function Vn(t,n){return M({name:"isIp",constraints:[t],validator:{validate:(t,n)=>En(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an ip address",n)}},n)}const Cn="isPort";function wn(n){return"string"==typeof n&&t.isPort(n)}function Tn(t){return M({name:"isPort",validator:{validate:(t,n)=>wn(t),defaultMessage:b(t=>t+"$property must be a port",t)}},t)}const xn="isIsbn";function Dn(n,e){const a=e?`${e}`:void 0;return"string"==typeof n&&t.isISBN(n,a)}function Ln(t,n){return M({name:"isIsbn",constraints:[t],validator:{validate:(t,n)=>Dn(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an ISBN",n)}},n)}const Pn="isIsin";function jn(n){return"string"==typeof n&&t.isISIN(n)}function Bn(t){return M({name:"isIsin",validator:{validate:(t,n)=>jn(t),defaultMessage:b(t=>t+"$property must be an ISIN (stock/security identifier)",t)}},t)}const Rn="isIso8601";function Un(n,e){return"string"==typeof n&&t.isISO8601(n,e)}function _n(t,n){return M({name:"isIso8601",constraints:[t],validator:{validate:(t,n)=>Un(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid ISO 8601 date string",n)}},n)}const Fn="isJson";function Hn(n){return"string"==typeof n&&t.isJSON(n)}function kn(t){return M({name:"isJson",validator:{validate:(t,n)=>Hn(t),defaultMessage:b(t=>t+"$property must be a json string",t)}},t)}const qn="isJwt";function Wn(n){return"string"==typeof n&&t.isJWT(n)}function zn(t){return M({name:"isJwt",validator:{validate:(t,n)=>Wn(t),defaultMessage:b(t=>t+"$property must be a jwt string",t)}},t)}const Jn="isLowercase";function Zn(n){return"string"==typeof n&&t.isLowercase(n)}function Gn(t){return M({name:"isLowercase",validator:{validate:(t,n)=>Zn(t),defaultMessage:b(t=>t+"$property must be a lowercase string",t)}},t)}const Kn="isMobilePhone";function Qn(n,e,a){return"string"==typeof n&&t.isMobilePhone(n,e,a)}function Yn(t,n,e){return M({name:"isMobilePhone",constraints:[t,n],validator:{validate:(t,n)=>Qn(t,n.constraints[0],n.constraints[1]),defaultMessage:b(t=>t+"$property must be a phone number",e)}},e)}const Xn="isISO31661Alpha2";function te(n){return"string"==typeof n&&t.isISO31661Alpha2(n)}function ne(t){return M({name:"isISO31661Alpha2",validator:{validate:(t,n)=>te(t),defaultMessage:b(t=>t+"$property must be a valid ISO31661 Alpha2 code",t)}},t)}const ee="isISO31661Alpha3";function ae(n){return"string"==typeof n&&t.isISO31661Alpha3(n)}function re(t){return M({name:"isISO31661Alpha3",validator:{validate:(t,n)=>ae(t),defaultMessage:b(t=>t+"$property must be a valid ISO31661 Alpha3 code",t)}},t)}const ie="isMongoId";function se(n){return"string"==typeof n&&t.isMongoId(n)}function oe(t){return M({name:"isMongoId",validator:{validate:(t,n)=>se(t),defaultMessage:b(t=>t+"$property must be a mongodb id",t)}},t)}const ce="isMultibyte";function ue(n){return"string"==typeof n&&t.isMultibyte(n)}function le(t){return M({name:"isMultibyte",validator:{validate:(t,n)=>ue(t),defaultMessage:b(t=>t+"$property must contain one or more multibyte chars",t)}},t)}const de="isSurrogatePair";function pe(n){return"string"==typeof n&&t.isSurrogatePair(n)}function fe(t){return M({name:"isSurrogatePair",validator:{validate:(t,n)=>pe(t),defaultMessage:b(t=>t+"$property must contain any surrogate pairs chars",t)}},t)}const me="isUrl";function ge(n,e){return"string"==typeof n&&t.isURL(n,e)}function ye(t,n){return M({name:"isUrl",constraints:[t],validator:{validate:(t,n)=>ge(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an URL address",n)}},n)}const ve="isUuid";function he(n,e){return"string"==typeof n&&t.isUUID(n,e)}function be(t,n){return M({name:"isUuid",constraints:[t],validator:{validate:(t,n)=>he(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an UUID",n)}},n)}const Me="IsFirebasePushId";function $e(t){return"string"==typeof t&&20===t.length&&/^[a-zA-Z0-9_-]*$/.test(t)}function Ie(t){return M({name:"IsFirebasePushId",validator:{validate:(t,n)=>$e(t),defaultMessage:b(t=>t+"$property must be a Firebase Push Id",t)}},t)}const Oe="isUppercase";function Ne(n){return"string"==typeof n&&t.isUppercase(n)}function Ae(t){return M({name:"isUppercase",validator:{validate:(t,n)=>Ne(t),defaultMessage:b(t=>t+"$property must be uppercase",t)}},t)}const Se="length";function Ee(n,e,a){return"string"==typeof n&&t.isLength(n,{min:e,max:a})}function Ve(t,n,e){return M({name:"length",constraints:[t,n],validator:{validate:(t,n)=>Ee(t,n.constraints[0],n.constraints[1]),defaultMessage:b((t,n)=>{const e=null!==n.constraints[0]&&void 0!==n.constraints[0],a=null!==n.constraints[1]&&void 0!==n.constraints[1];return e&&(!n.value||n.value.length<n.constraints[0])?t+"$property must be longer than or equal to $constraint1 characters":a&&n.value.length>n.constraints[1]?t+"$property must be shorter than or equal to $constraint2 characters":t+"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters"},e)}},e)}const Ce="maxLength";function we(n,e){return"string"==typeof n&&t.isLength(n,{min:0,max:e})}function Te(t,n){return M({name:"maxLength",constraints:[t],validator:{validate:(t,n)=>we(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be shorter than or equal to $constraint1 characters",n)}},n)}const xe="minLength";function De(n,e){return"string"==typeof n&&t.isLength(n,{min:e})}function Le(t,n){return M({name:"minLength",constraints:[t],validator:{validate:(t,n)=>De(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be longer than or equal to $constraint1 characters",n)}},n)}const Pe="matches";function je(n,e,a){return"string"==typeof n&&t.matches(n,e,a)}function Be(t,n,e){let a;return n&&n instanceof Object&&!e?e=n:a=n,M({name:"matches",constraints:[t,a],validator:{validate:(t,n)=>je(t,n.constraints[0],n.constraints[0]),defaultMessage:b((t,n)=>t+"$property must match $constraint1 regular expression",e)}},e)}const Re="isPhoneNumber";function Ue(t,e){const a=n.getInstance();try{const n=a.parseAndKeepRawInput(t,e);return a.isValidNumber(n)}catch(t){return!1}}function _e(t,n){return M({name:"isPhoneNumber",constraints:[t],validator:{validate:(t,n)=>Ue(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid phone number",n)}},n)}const Fe="isMilitaryTime";function He(n){return"string"==typeof n&&t.matches(n,/^([01]\d|2[0-3]):?([0-5]\d)$/)}function ke(t){return M({name:"isMilitaryTime",validator:{validate:(t,n)=>He(t),defaultMessage:b(t=>t+"$property must be a valid representation of military time in the format HH:MM",t)}},t)}const qe="isHash";function We(n,e){return"string"==typeof n&&t.isHash(n,e)}function ze(t,n){return M({name:"isHash",constraints:[t],validator:{validate:(t,n)=>We(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a hash of type $constraint1",n)}},n)}const Je="isISSN";function Ze(n,e){return"string"==typeof n&&t.isISSN(n,e)}function Ge(t,n){return M({name:"isISSN",constraints:[t],validator:{validate:(t,n)=>Ze(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a ISSN",n)}},n)}const Ke="isDateString";function Qe(t){return"string"==typeof t&&/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:Z|[\+\-][0-2]\d(?:\:[0-5]\d)?)?$/g.test(t)}function Ye(t){return M({name:"isDateString",validator:{validate:(t,n)=>Qe(t),defaultMessage:b(t=>t+"$property must be a ISOString",t)}},t)}const Xe="isBooleanString";function ta(n){return"string"==typeof n&&t.isBoolean(n)}function na(t){return M({name:"isBooleanString",validator:{validate:(t,n)=>ta(t),defaultMessage:b(t=>t+"$property must be a boolean string",t)}},t)}const ea="isNumberString";function aa(n,e){return"string"==typeof n&&t.isNumeric(n,e)}function ra(t,n){return M({name:"isNumberString",constraints:[t],validator:{validate:(t,n)=>aa(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a number string",n)}},n)}const ia="isBase32";function sa(n){return"string"==typeof n&&t.isBase32(n)}function oa(t){return M({name:"isBase32",validator:{validate:(t,n)=>sa(t),defaultMessage:b(t=>t+"$property must be base32 encoded",t)}},t)}const ca="isBIC";function ua(n){return"string"==typeof n&&t.isBIC(n)}function la(t){return M({name:"isBIC",validator:{validate:(t,n)=>ua(t),defaultMessage:b(t=>t+"$property must be a BIC or SWIFT code",t)}},t)}const da="isBtcAddress";function pa(n){return"string"==typeof n&&t.isBtcAddress(n)}function fa(t){return M({name:"isBtcAddress",validator:{validate:(t,n)=>pa(t),defaultMessage:b(t=>t+"$property must be a BTC address",t)}},t)}const ma="isDataURI";function ga(n){return"string"==typeof n&&t.isDataURI(n)}function ya(t){return M({name:"isDataURI",validator:{validate:(t,n)=>ga(t),defaultMessage:b(t=>t+"$property must be a data uri format",t)}},t)}const va="isEAN";function ha(n){return"string"==typeof n&&t.isEAN(n)}function ba(t){return M({name:"isEAN",validator:{validate:(t,n)=>ha(t),defaultMessage:b(t=>t+"$property must be an EAN (European Article Number)",t)}},t)}const Ma="isEthereumAddress";function $a(n){return"string"==typeof n&&t.isEthereumAddress(n)}function Ia(t){return M({name:"isEthereumAddress",validator:{validate:(t,n)=>$a(t),defaultMessage:b(t=>t+"$property must be an Ethereum address",t)}},t)}const Oa="isHSL";function Na(n){return"string"==typeof n&&t.isHSL(n)}function Aa(t){return M({name:"isHSL",validator:{validate:(t,n)=>Na(t),defaultMessage:b(t=>t+"$property must be a HSL color",t)}},t)}const Sa="isIBAN";function Ea(n){return"string"==typeof n&&t.isIBAN(n)}function Va(t){return M({name:"isIBAN",validator:{validate:(t,n)=>Ea(t),defaultMessage:b(t=>t+"$property must be an IBAN",t)}},t)}const Ca="isIdentityCard";function wa(n,e){return"string"==typeof n&&t.isIdentityCard(n,e)}function Ta(t,n){return M({name:"isIdentityCard",constraints:[t],validator:{validate:(t,n)=>wa(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a identity card number",n)}},n)}const xa="isISRC";function Da(n){return"string"==typeof n&&t.isISRC(n)}function La(t){return M({name:"isISRC",validator:{validate:(t,n)=>Da(t),defaultMessage:b(t=>t+"$property must be an ISRC",t)}},t)}const Pa="isLocale";function ja(n){return"string"==typeof n&&t.isLocale(n)}function Ba(t){return M({name:"isLocale",validator:{validate:(t,n)=>ja(t),defaultMessage:b(t=>t+"$property must be locale",t)}},t)}const Ra="isMagnetURI";function Ua(n){return"string"==typeof n&&t.isMagnetURI(n)}function _a(t){return M({name:"isMagnetURI",validator:{validate:(t,n)=>Ua(t),defaultMessage:b(t=>t+"$property must be magnet uri format",t)}},t)}const Fa="isMimeType";function Ha(n){return"string"==typeof n&&t.isMimeType(n)}function ka(t){return M({name:"isMimeType",validator:{validate:(t,n)=>Ha(t),defaultMessage:b(t=>t+"$property must be MIME type format",t)}},t)}const qa="isOctal";function Wa(n){return"string"==typeof n&&t.isOctal(n)}function za(t){return M({name:"isOctal",validator:{validate:(t,n)=>Wa(t),defaultMessage:b(t=>t+"$property must be valid octal number",t)}},t)}const Ja="isPassportNumber";function Za(n,e){return"string"==typeof n&&t.isPassportNumber(n,e)}function Ga(t,n){return M({name:"isPassportNumber",constraints:[t],validator:{validate:(t,n)=>Za(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be valid passport number",n)}},n)}const Ka="isPostalCode";function Qa(n,e){return"string"==typeof n&&t.isPostalCode(n,e)}function Ya(t,n){return M({name:"isPostalCode",constraints:[t],validator:{validate:(t,n)=>Qa(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a postal code",n)}},n)}const Xa="isRFC3339";function tr(n){return"string"==typeof n&&t.isRFC3339(n)}function nr(t){return M({name:"isRFC3339",validator:{validate:(t,n)=>tr(t),defaultMessage:b(t=>t+"$property must be RFC 3339 date",t)}},t)}const er="isRgbColor";function ar(n,e){return"string"==typeof n&&t.isRgbColor(n,e)}function rr(t,n){return M({name:"isRgbColor",constraints:[t],validator:{validate:(t,n)=>ar(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be RGB color",n)}},n)}const ir="isSemVer";function sr(n){return"string"==typeof n&&t.isSemVer(n)}function or(t){return M({name:"isSemVer",validator:{validate:(t,n)=>sr(t),defaultMessage:b(t=>t+"$property must be a Semantic Versioning Specification",t)}},t)}const cr="isBoolean";function ur(t){return t instanceof Boolean||"boolean"==typeof t}function lr(t){return M({name:"isBoolean",validator:{validate:(t,n)=>ur(t),defaultMessage:b(t=>t+"$property must be a boolean value",t)}},t)}const dr="isDate";function pr(t){return t instanceof Date&&!isNaN(t.getTime())}function fr(t){return M({name:"isDate",validator:{validate:(t,n)=>pr(t),defaultMessage:b(t=>t+"$property must be a Date instance",t)}},t)}const mr="isNumber";function gr(t,n={}){if("number"!=typeof t)return!1;if(t===1/0||t===-1/0)return n.allowInfinity;if(Number.isNaN(t))return n.allowNaN;if(void 0!==n.maxDecimalPlaces){let e=0;if(t%1!=0&&(e=t.toString().split(".")[1].length),e>n.maxDecimalPlaces)return!1}return Number.isFinite(t)}function yr(t={},n){return M({name:"isNumber",constraints:[t],validator:{validate:(t,n)=>gr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a number conforming to the specified constraints",n)}},n)}const vr="isEnum";function hr(t,n){return Object.keys(n).map(t=>n[t]).indexOf(t)>=0}function br(t,n){return M({name:"isEnum",constraints:[t],validator:{validate:(t,n)=>hr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid enum value",n)}},n)}const Mr="isInt";function $r(t){return"number"==typeof t&&Number.isInteger(t)}function Ir(t){return M({name:"isInt",validator:{validate:(t,n)=>$r(t),defaultMessage:b(t=>t+"$property must be an integer number",t)}},t)}const Or="isString";function Nr(t){return t instanceof String||"string"==typeof t}function Ar(t){return M({name:"isString",validator:{validate:(t,n)=>Nr(t),defaultMessage:b(t=>t+"$property must be a string",t)}},t)}const Sr="isArray";function Er(t){return t instanceof Array}function Vr(t){return M({name:"isArray",validator:{validate:(t,n)=>Er(t),defaultMessage:b(t=>t+"$property must be an array",t)}},t)}const Cr="isObject";function wr(t){return null!=t&&("object"==typeof t||"function"==typeof t)&&!Array.isArray(t)}function Tr(t){return M({name:"isObject",validator:{validate:(t,n)=>wr(t),defaultMessage:b(t=>t+"$property must be an object",t)}},t)}const xr="arrayContains";function Dr(t,n){return t instanceof Array&&n.every(n=>-1!==t.indexOf(n))}function Lr(t,n){return M({name:"arrayContains",constraints:[t],validator:{validate:(t,n)=>Dr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain $constraint1 values",n)}},n)}const Pr="arrayNotContains";function jr(t,n){return t instanceof Array&&n.every(n=>-1===t.indexOf(n))}function Br(t,n){return M({name:"arrayNotContains",constraints:[t],validator:{validate:(t,n)=>jr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not contain $constraint1 values",n)}},n)}const Rr="arrayNotEmpty";function Ur(t){return t instanceof Array&&t.length>0}function _r(t){return M({name:"arrayNotEmpty",validator:{validate:(t,n)=>Ur(t),defaultMessage:b(t=>t+"$property should not be empty",t)}},t)}const Fr="arrayMinSize";function Hr(t,n){return t instanceof Array&&t.length>=n}function kr(t,n){return M({name:"arrayMinSize",constraints:[t],validator:{validate:(t,n)=>Hr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain at least $constraint1 elements",n)}},n)}const qr="arrayMaxSize";function Wr(t,n){return t instanceof Array&&t.length<=n}function zr(t,n){return M({name:"arrayMaxSize",constraints:[t],validator:{validate:(t,n)=>Wr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain not more than $constraint1 elements",n)}},n)}const Jr="arrayUnique";function Zr(t){if(!(t instanceof Array))return!1;const n=t.filter((t,n,e)=>e.indexOf(t)===n);return t.length===n.length}function Gr(t){return M({name:"arrayUnique",validator:{validate:(t,n)=>Zr(t),defaultMessage:b(t=>t+"All $property's elements must be unique",t)}},t)}const Kr="isNotEmptyObject";function Qr(t){if(!wr(t))return!1;for(const n in t)if(t.hasOwnProperty(n))return!0;return!1}function Yr(t){return M({name:"isNotEmptyObject",validator:{validate:(t,n)=>Qr(t),defaultMessage:b(t=>t+"$property must be a non-empty object",t)}},t)}const Xr="isInstance";function ti(t,n){return n&&"function"==typeof n&&t instanceof n}function ni(t,n){return M({name:"isInstance",constraints:[t],validator:{validate:(t,n)=>ti(t,n.constraints[0]),defaultMessage:b((t,n)=>n.constraints[0]?t+`$property must be an instance of ${n.constraints[0].name}`:t+"isInstance decorator expects and object as value, but got falsy value.",n)}},n)}function ei(t,n,e){return"string"==typeof t?g(l).validate(t,n,e):g(l).validate(t,n)}function ai(t,n,e){return"string"==typeof t?g(l).validateOrReject(t,n,e):g(l).validateOrReject(t,n)}function ri(t,n,e){return"string"==typeof t?g(l).validateSync(t,n,e):g(l).validateSync(t,n)}function ii(t){r().addValidationSchema(t)}export{xr as ARRAY_CONTAINS,qr as ARRAY_MAX_SIZE,Fr as ARRAY_MIN_SIZE,Pr as ARRAY_NOT_CONTAINS,Rr as ARRAY_NOT_EMPTY,Jr as ARRAY_UNIQUE,y as Allow,Lr as ArrayContains,zr as ArrayMaxSize,kr as ArrayMinSize,Br as ArrayNotContains,_r as ArrayNotEmpty,Gr as ArrayUnique,Nt as CONTAINS,St as Contains,U as EQUALS,F as Equals,wt as IS_ALPHA,Dt as IS_ALPHANUMERIC,Sr as IS_ARRAY,Ut as IS_ASCII,ia as IS_BASE32,Ht as IS_BASE64,ca as IS_BIC,cr as IS_BOOLEAN,Xe as IS_BOOLEAN_STRING,da as IS_BTC_ADDRESS,Wt as IS_BYTE_LENGTH,Zt as IS_CREDIT_CARD,Qt as IS_CURRENCY,ma as IS_DATA_URI,dr as IS_DATE,Ke as IS_DATE_STRING,jt as IS_DECIMAL,$ as IS_DEFINED,at as IS_DIVISIBLE_BY,va as IS_EAN,tn as IS_EMAIL,W as IS_EMPTY,vr as IS_ENUM,Ma as IS_ETHEREUM_ADDRESS,Me as IS_FIREBASE_PUSH_ID,an as IS_FQDN,on as IS_FULL_WIDTH,ln as IS_HALF_WIDTH,qe as IS_HASH,bn as IS_HEXADECIMAL,yn as IS_HEX_COLOR,Oa as IS_HSL,Sa as IS_IBAN,Ca as IS_IDENTITY_CARD,Q as IS_IN,Xr as IS_INSTANCE,Mr as IS_INT,Sn as IS_IP,xn as IS_ISBN,Pn as IS_ISIN,Xn as IS_ISO31661_ALPHA_2,ee as IS_ISO31661_ALPHA_3,Rn as IS_ISO8601,xa as IS_ISRC,Je as IS_ISSN,Fn as IS_JSON,qn as IS_JWT,D as IS_LATITUDE,w as IS_LATLONG,Pa as IS_LOCALE,j as IS_LONGITUDE,Jn as IS_LOWERCASE,On as IS_MAC_ADDRESS,Ra as IS_MAGNET_URI,Fe as IS_MILITARY_TIME,Fa as IS_MIME_TYPE,Kn as IS_MOBILE_PHONE,ie as IS_MONGO_ID,ce as IS_MULTIBYTE,ut as IS_NEGATIVE,Z as IS_NOT_EMPTY,Kr as IS_NOT_EMPTY_OBJECT,tt as IS_NOT_IN,mr as IS_NUMBER,ea as IS_NUMBER_STRING,Cr as IS_OBJECT,qa as IS_OCTAL,Ja as IS_PASSPORT_NUMBER,Re as IS_PHONE_NUMBER,Cn as IS_PORT,st as IS_POSITIVE,Ka as IS_POSTAL_CODE,Xa as IS_RFC_3339,er as IS_RGB_COLOR,ir as IS_SEM_VER,Or as IS_STRING,de as IS_SURROGATE_PAIR,Oe as IS_UPPERCASE,me as IS_URL,ve as IS_UUID,fn as IS_VARIABLE_WIDTH,xt as IsAlpha,Pt as IsAlphanumeric,Vr as IsArray,Ft as IsAscii,la as IsBIC,oa as IsBase32,qt as IsBase64,lr as IsBoolean,na as IsBooleanString,fa as IsBtcAddress,Jt as IsByteLength,Kt as IsCreditCard,Xt as IsCurrency,ya as IsDataURI,fr as IsDate,Ye as IsDateString,Rt as IsDecimal,O as IsDefined,it as IsDivisibleBy,ba as IsEAN,en as IsEmail,J as IsEmpty,br as IsEnum,Ia as IsEthereumAddress,sn as IsFQDN,Ie as IsFirebasePushId,un as IsFullWidth,Aa as IsHSL,pn as IsHalfWidth,ze as IsHash,hn as IsHexColor,$n as IsHexadecimal,Va as IsIBAN,Vn as IsIP,Ln as IsISBN,Bn as IsISIN,ne as IsISO31661Alpha2,re as IsISO31661Alpha3,_n as IsISO8601,La as IsISRC,Ge as IsISSN,Ta as IsIdentityCard,X as IsIn,ni as IsInstance,Ir as IsInt,kn as IsJSON,zn as IsJWT,x as IsLatLong,P as IsLatitude,Ba as IsLocale,R as IsLongitude,Gn as IsLowercase,An as IsMACAddress,_a as IsMagnetURI,ke as IsMilitaryTime,ka as IsMimeType,Yn as IsMobilePhone,oe as IsMongoId,le as IsMultibyte,dt as IsNegative,K as IsNotEmpty,Yr as IsNotEmptyObject,et as IsNotIn,yr as IsNumber,ra as IsNumberString,Tr as IsObject,za as IsOctal,N as IsOptional,Ga as IsPassportNumber,_e as IsPhoneNumber,Tn as IsPort,ct as IsPositive,Ya as IsPostalCode,nr as IsRFC3339,rr as IsRgbColor,or as IsSemVer,Ar as IsString,fe as IsSurrogatePair,be as IsUUID,Ae as IsUppercase,ye as IsUrl,gn as IsVariableWidth,Se as LENGTH,Ve as Length,Pe as MATCHES,pt as MAX,$t as MAX_DATE,Ce as MAX_LENGTH,gt as MIN,ht as MIN_DATE,xe as MIN_LENGTH,Be as Matches,mt as Max,Ot as MaxDate,Te as MaxLength,i as MetadataStorage,vt as Min,Mt as MinDate,Le as MinLength,Et as NOT_CONTAINS,H as NOT_EQUALS,Ct as NotContains,q as NotEquals,S as Validate,M as ValidateBy,E as ValidateIf,V as ValidateNested,C as ValidatePromise,s as ValidationError,o as ValidationTypes,l as Validator,A as ValidatorConstraint,Dr as arrayContains,Wr as arrayMaxSize,Hr as arrayMinSize,jr as arrayNotContains,Ur as arrayNotEmpty,Zr as arrayUnique,b as buildMessage,At as contains,_ as equals,g as getFromContainer,r as getMetadataStorage,Tt as isAlpha,Lt as isAlphanumeric,Er as isArray,_t as isAscii,ua as isBIC,sa as isBase32,kt as isBase64,ur as isBoolean,ta as isBooleanString,pa as isBtcAddress,zt as isByteLength,Gt as isCreditCard,Yt as isCurrency,ga as isDataURI,pr as isDate,Qe as isDateString,Bt as isDecimal,I as isDefined,rt as isDivisibleBy,ha as isEAN,nn as isEmail,z as isEmpty,hr as isEnum,$a as isEthereumAddress,rn as isFQDN,$e as isFirebasePushId,cn as isFullWidth,Na as isHSL,dn as isHalfWidth,We as isHash,vn as isHexColor,Mn as isHexadecimal,Ea as isIBAN,En as isIP,Dn as isISBN,jn as isISIN,te as isISO31661Alpha2,ae as isISO31661Alpha3,Un as isISO8601,Da as isISRC,Ze as isISSN,wa as isIdentityCard,Y as isIn,ti as isInstance,$r as isInt,Hn as isJSON,Wn as isJWT,T as isLatLong,L as isLatitude,ja as isLocale,B as isLongitude,Zn as isLowercase,Nn as isMACAddress,Ua as isMagnetURI,He as isMilitaryTime,Ha as isMimeType,Qn as isMobilePhone,se as isMongoId,ue as isMultibyte,lt as isNegative,G as isNotEmpty,Qr as isNotEmptyObject,nt as isNotIn,gr as isNumber,aa as isNumberString,wr as isObject,Wa as isOctal,Za as isPassportNumber,Ue as isPhoneNumber,wn as isPort,ot as isPositive,Qa as isPostalCode,tr as isRFC3339,ar as isRgbColor,sr as isSemVer,Nr as isString,pe as isSurrogatePair,ge as isURL,he as isUUID,Ne as isUppercase,In as isValidationOptions,mn as isVariableWidth,Ee as length,je as matches,ft as max,It as maxDate,we as maxLength,yt as min,bt as minDate,De as minLength,Vt as notContains,k as notEquals,h as registerDecorator,ii as registerSchema,m as useContainer,ei as validate,ai as validateOrReject,ri as validateSync};
+import t from"validator";import{PhoneNumberUtil as n}from"google-libphonenumber";class e{constructor(t){this.groups=[],this.always=!1,this.each=!1,this.context=void 0,this.type=t.type,this.target=t.target,this.propertyName=t.propertyName,this.constraints=t.constraints,this.constraintCls=t.constraintCls,this.validationTypeOptions=t.validationTypeOptions,t.validationOptions&&(this.message=t.validationOptions.message,this.groups=t.validationOptions.groups,this.always=t.validationOptions.always,this.each=t.validationOptions.each,this.context=t.validationOptions.context)}}class a{transform(t){const n=[];return Object.keys(t.properties).forEach(a=>{t.properties[a].forEach(r=>{const i={message:r.message,groups:r.groups,always:r.always,each:r.each},s={type:r.type,target:t.name,propertyName:a,constraints:r.constraints,validationTypeOptions:r.options,validationOptions:i};n.push(new e(s))})}),n}}function r(){return"undefined"!=typeof window&&(window.global=window),global.classValidatorMetadataStorage||(global.classValidatorMetadataStorage=new i),global.classValidatorMetadataStorage}class i{constructor(){this.validationMetadatas=[],this.constraintMetadatas=[]}get hasValidationMetaData(){return!!this.validationMetadatas.length}addValidationSchema(t){(new a).transform(t).forEach(t=>this.addValidationMetadata(t))}addValidationMetadata(t){this.validationMetadatas.push(t)}addConstraintMetadata(t){this.constraintMetadatas.push(t)}groupByPropertyName(t){const n={};return t.forEach(t=>{n[t.propertyName]||(n[t.propertyName]=[]),n[t.propertyName].push(t)}),n}getTargetValidationMetadatas(t,n,e){const a=this.validationMetadatas.filter(a=>(a.target===t||a.target===n)&&(!!a.always||(!(e&&e.length>0)||a.groups&&!!a.groups.find(t=>-1!==e.indexOf(t))))),r=this.validationMetadatas.filter(n=>"string"!=typeof n.target&&(n.target!==t&&((!(n.target instanceof Function)||t.prototype instanceof n.target)&&(!!n.always||(!(e&&e.length>0)||n.groups&&!!n.groups.find(t=>-1!==e.indexOf(t))))))).filter(t=>!a.find(n=>n.propertyName===t.propertyName&&n.type===t.type));return a.concat(r)}getTargetValidatorConstraints(t){return this.constraintMetadatas.filter(n=>n.target===t)}}class s{toString(t=!1,n=!1,e=""){const a=t?"[1m":"",r=t?"[22m":"",i=t=>` - property ${a}${e}${t}${r} has failed the following constraints: ${a}${Object.keys(this.constraints).join(", ")}${r} \n`;if(n){const n=Number.isInteger(+this.property)?`[${this.property}]`:`${e?".":""}${this.property}`;return this.constraints?i(n):this.children.map(a=>a.toString(t,!0,`${e}${n}`)).join("")}return`An instance of ${a}${this.target?this.target.constructor.name:"an object"}${r} has failed the validation:\n`+(this.constraints?i(this.property):"")+this.children.map(n=>n.toString(t,!0,this.property)).join("")}}class o{static isValid(t){return"isValid"!==t&&"getMessage"!==t&&-1!==Object.keys(this).map(t=>this[t]).indexOf(t)}}o.CUSTOM_VALIDATION="customValidation",o.NESTED_VALIDATION="nestedValidation",o.PROMISE_VALIDATION="promiseValidation",o.CONDITIONAL_VALIDATION="conditionalValidation",o.WHITELIST="whitelistValidation",o.IS_DEFINED="isDefined";function u(t){return null!==t&&"object"==typeof t&&"function"==typeof t.then}class c{constructor(t,n){this.validator=t,this.validatorOptions=n,this.awaitingPromises=[],this.ignoreAsyncValidations=!1,this.metadataStorage=r()}execute(t,n,e){this.metadataStorage.hasValidationMetaData||console.warn("No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.");const a=this.validatorOptions?this.validatorOptions.groups:void 0,r=this.metadataStorage.getTargetValidationMetadatas(t.constructor,n,a),i=this.metadataStorage.groupByPropertyName(r);if(this.validatorOptions&&this.validatorOptions.forbidUnknownValues&&!r.length){const n=new s;return this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.target&&!0!==this.validatorOptions.validationError.target||(n.target=t),n.value=void 0,n.property=void 0,n.children=[],n.constraints=["an unknown value was passed to the validate function"],void e.push(n)}this.validatorOptions&&this.validatorOptions.whitelist&&this.whitelist(t,i,e),Object.keys(i).forEach(n=>{const a=t[n],r=i[n].filter(t=>t.type===o.IS_DEFINED),s=i[n].filter(t=>t.type!==o.IS_DEFINED&&t.type!==o.WHITELIST);a instanceof Promise&&s.find(t=>t.type===o.PROMISE_VALIDATION)?this.awaitingPromises.push(a.then(a=>{this.performValidations(t,a,n,r,s,e)})):this.performValidations(t,a,n,r,s,e)})}whitelist(t,n,e){let a=[];Object.keys(t).forEach(t=>{n[t]&&0!==n[t].length||a.push(t)}),a.length>0&&(this.validatorOptions&&this.validatorOptions.forbidNonWhitelisted?a.forEach(n=>{const a=this.generateValidationError(t,t[n],n);a.constraints=[`property ${n} should not exist`],a.children=void 0,e.push(a)}):a.forEach(n=>delete t[n]))}stripEmptyErrors(t){return t.filter(t=>{if(t.children&&(t.children=this.stripEmptyErrors(t.children)),0===t.constraints.length){if(0===t.children.length)return!1;delete t.constraints}return!0})}performValidations(t,n,e,a,r,i){const s=r.filter(t=>t.type===o.CUSTOM_VALIDATION),u=r.filter(t=>t.type===o.NESTED_VALIDATION),c=r.filter(t=>t.type===o.CONDITIONAL_VALIDATION),l=this.generateValidationError(t,n,e);i.push(l),this.conditionalValidations(t,n,c)&&(this.customValidations(t,n,a,l),void 0===n&&this.validatorOptions&&!0===this.validatorOptions.skipUndefinedProperties||null===n&&this.validatorOptions&&!0===this.validatorOptions.skipNullProperties||null==n&&this.validatorOptions&&!0===this.validatorOptions.skipMissingProperties||(this.customValidations(t,n,s,l),this.nestedValidations(n,u,l.children)))}generateValidationError(t,n,e){const a=new s;return this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.target&&!0!==this.validatorOptions.validationError.target||(a.target=t),this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.value&&!0!==this.validatorOptions.validationError.value||(a.value=n),a.property=e,a.children=[],a.constraints=[],a}conditionalValidations(t,n,e){return e.map(e=>e.constraints[0](t,n)).reduce((t,n)=>t&&n,!0)}customValidations(t,n,e,a){e.forEach(e=>{this.metadataStorage.getTargetValidatorConstraints(e.constraintCls).forEach(r=>{if(r.async&&this.ignoreAsyncValidations)return;const i={targetName:t.constructor?t.constructor.name:void 0,property:e.propertyName,object:t,value:n,constraints:e.constraints};if(!e.each||!(n instanceof Array||n instanceof Set||n instanceof Map)){const s=r.instance.validate(n,i);if(u(s)){const i=s.then(i=>{if(!i){const[i,s]=this.createValidationError(t,n,e,r);a.constraints.push(s),e.context&&(a.contexts||(a.contexts={}),a.contexts[i]=Object.assign(a.contexts[i]||{},e.context))}});this.awaitingPromises.push(i)}else if(!s){const[i,s]=this.createValidationError(t,n,e,r);a.constraints.push(s)}return}var s;const o=((s=n)instanceof Map?Array.from(s.values()):Array.isArray(s)?s:Array.from(s)).map(t=>r.instance.validate(t,i));if(o.some(t=>u(t))){const i=o.map(t=>u(t)?t:Promise.resolve(t)),s=Promise.all(i).then(i=>{if(!i.every(t=>t)){const[i,s]=this.createValidationError(t,n,e,r);a.constraints.push(s),e.context&&(a.contexts||(a.contexts={}),a.contexts[i]=Object.assign(a.contexts[i]||{},e.context))}});this.awaitingPromises.push(s)}else if(!o.every(t=>t)){const[i,s]=this.createValidationError(t,n,e,r);a.constraints.push(s)}})})}nestedValidations(t,n,e){void 0!==t&&n.forEach(a=>{if(a.type===o.NESTED_VALIDATION||a.type===o.PROMISE_VALIDATION)if(t instanceof Array||t instanceof Set||t instanceof Map){(t instanceof Set?Array.from(t):t).forEach((a,r)=>{this.performValidations(t,a,r.toString(),[],n,e)})}else if(t instanceof Object){const n="string"==typeof a.target?a.target:a.target.name;this.execute(t,n,e)}else{const n=new s;n.value=t,n.property=a.propertyName,n.target=a.target;const[r,i]=this.createValidationError(a.target,t,a);n.constraints=[i],e.push(n)}})}createValidationError(t,n,e,a){const r=t.constructor?t.constructor.name:void 0,i=this.getConstraintType(e,a),s={targetName:r,property:e.propertyName,object:t,value:n,constraints:e.constraints};let o=e.message||"";return e.message||this.validatorOptions&&(!this.validatorOptions||this.validatorOptions.dismissDefaultMessages)||a&&a.instance.defaultMessage instanceof Function&&(o=a.instance.defaultMessage(s)),[i,class{static replaceMessageSpecialTokens(t,n){let e;return t instanceof Function?e=t(n):"string"==typeof t&&(e=t),e&&n.constraints instanceof Array&&n.constraints.forEach((t,n)=>{e=e.replace(new RegExp(`\\$constraint${n+1}`,"g"),t)}),e&&void 0!==n.value&&null!==n.value&&"string"==typeof n.value&&(e=e.replace(/\$value/g,n.value)),e&&(e=e.replace(/\$property/g,n.property)),e&&(e=e.replace(/\$target/g,n.targetName)),e}}.replaceMessageSpecialTokens(o,s)]}getConstraintType(t,n){return n&&n.name?n.name:t.type}}class l{coreValidate(t,n,e){const a="string"==typeof t?n:t,r="string"==typeof t?t:void 0,i=new c(this,"string"==typeof t?e:n),s=[];return i.execute(a,r,s),Promise.all(i.awaitingPromises).then(()=>i.stripEmptyErrors(s))}validate(t,n,e){return this.coreValidate(t,n,e)}async validateOrReject(t,n,e){const a=await this.coreValidate(t,n,e);if(a.length)return Promise.reject(a)}validateSync(t,n,e){const a="string"==typeof t?n:t,r="string"==typeof t?t:void 0,i=new c(this,"string"==typeof t?e:n);i.ignoreAsyncValidations=!0;const s=[];return i.execute(a,r,s),i.stripEmptyErrors(s)}}const d=new class{constructor(){this.instances=[]}get(t){let n=this.instances.find(n=>n.type===t);return n||(n={type:t,object:new t},this.instances.push(n)),n.object}};let p,f;function m(t,n){p=t,f=n}function g(t){if(p)try{const n=p.get(t);if(n)return n;if(!f||!f.fallback)return n}catch(t){if(!f||!f.fallbackOnErrors)throw t}return d.get(t)}function y(t){return function(n,a){const i={type:o.WHITELIST,target:n.constructor,propertyName:a,validationOptions:t};r().addValidationMetadata(new e(i))}}class v{constructor(t,n,e=!1){this.target=t,this.name=n,this.async=e}get instance(){return g(this.target)}}function h(t){let n;if(t.validator instanceof Function){if(n=t.validator,g(i).getTargetValidatorConstraints(t.validator).length>1)throw`More than one implementation of ValidatorConstraintInterface found for validator on: ${t.target}:${t.propertyName}`}else{const e=t.validator;n=class{validate(t,n){return e.validate(t,n)}defaultMessage(t){return e.defaultMessage?e.defaultMessage(t):""}},r().addConstraintMetadata(new v(n,t.name,t.async))}const a={type:t.name&&o.isValid(t.name)?t.name:o.CUSTOM_VALIDATION,target:t.target,propertyName:t.propertyName,validationOptions:t.options,constraintCls:n,constraints:t.constraints};r().addValidationMetadata(new e(a))}function b(t,n){return e=>{const a=n&&n.each?"each value in ":"";return t(a,e)}}function M(t,n){return function(e,a){h({name:t.name,target:e.constructor,propertyName:a,options:n,constraints:t.constraints,validator:t.validator})}}const $=o.IS_DEFINED;function I(t){return null!=t}function O(t){return M({name:$,validator:{validate:t=>I(t),defaultMessage:b(t=>t+"$property should not be null or undefined",t)}},t)}function N(t){return function(n,a){const i={type:o.CONDITIONAL_VALIDATION,target:n.constructor,propertyName:a,constraints:[(t,n)=>null!==t[a]&&void 0!==t[a]],validationOptions:t};r().addValidationMetadata(new e(i))}}function A(t){return function(n){const e=!(!t||!t.async);let a=t&&t.name?t.name:"";a||(a=n.name,a||(a=a.replace(/\.?([A-Z]+)/g,(t,n)=>"_"+n.toLowerCase()).replace(/^_/,"")));const i=new v(n,a,e);r().addConstraintMetadata(i)}}function S(t,n,a){return function(i,s){const u={type:o.CUSTOM_VALIDATION,target:i.constructor,propertyName:s,constraintCls:t,constraints:n instanceof Array?n:void 0,validationOptions:n instanceof Array?a:n};r().addValidationMetadata(new e(u))}}function E(t,n){return function(a,i){const s={type:o.CONDITIONAL_VALIDATION,target:a.constructor,propertyName:i,constraints:[t],validationOptions:n};r().addValidationMetadata(new e(s))}}function V(t){const n={...t},a=n.each?"each value in ":"";return n.message=n.message||a+"nested property $property must be either object or array",function(t,a){const i={type:o.NESTED_VALIDATION,target:t.constructor,propertyName:a,validationOptions:n};r().addValidationMetadata(new e(i))}}function w(t){return function(n,a){const i={type:o.PROMISE_VALIDATION,target:n.constructor,propertyName:a,validationOptions:t};r().addValidationMetadata(new e(i))}}const C="isLatLong";function D(n){return"string"==typeof n&&t.isLatLong(n)}function T(t){return M({name:"isLatLong",validator:{validate:(t,n)=>D(t),defaultMessage:b(t=>t+"$property must be a latitude,longitude string",t)}},t)}const L="isLatitude";function x(t){return("number"==typeof t||"string"==typeof t)&&D(`${t},0`)}function P(t){return M({name:"isLatitude",validator:{validate:(t,n)=>x(t),defaultMessage:b(t=>t+"$property must be a latitude string or number",t)}},t)}const B="isLongitude";function j(t){return("number"==typeof t||"string"==typeof t)&&D(`0,${t}`)}function R(t){return M({name:"isLongitude",validator:{validate:(t,n)=>j(t),defaultMessage:b(t=>t+"$property must be a longitude string or number",t)}},t)}const U="equals";function F(t,n){return t===n}function _(t,n){return M({name:"equals",constraints:[t],validator:{validate:(t,n)=>F(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be equal to $constraint1",n)}},n)}const H="notEquals";function q(t,n){return t!==n}function k(t,n){return M({name:"notEquals",constraints:[t],validator:{validate:(t,n)=>q(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not be equal to $constraint1",n)}},n)}const W="isEmpty";function z(t){return""===t||null==t}function J(t){return M({name:"isEmpty",validator:{validate:(t,n)=>z(t),defaultMessage:b(t=>t+"$property must be empty",t)}},t)}const Z="isNotEmpty";function G(t){return""!==t&&null!=t}function K(t){return M({name:"isNotEmpty",validator:{validate:(t,n)=>G(t),defaultMessage:b(t=>t+"$property should not be empty",t)}},t)}const Q="isIn";function Y(t,n){return!(n instanceof Array)||n.some(n=>n===t)}function X(t,n){return M({name:"isIn",constraints:[t],validator:{validate:(t,n)=>Y(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be one of the following values: $constraint1",n)}},n)}const tt="isNotIn";function nt(t,n){return!(n instanceof Array&&n.some(n=>n===t))}function et(t,n){return M({name:"isNotIn",constraints:[t],validator:{validate:(t,n)=>nt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not be one of the following values: $constraint1",n)}},n)}const at="isDivisibleBy";function rt(n,e){return"number"==typeof n&&"number"==typeof e&&t.isDivisibleBy(String(n),e)}function it(t,n){return M({name:"isDivisibleBy",constraints:[t],validator:{validate:(t,n)=>rt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be divisible by $constraint1",n)}},n)}const st="isPositive";function ot(t){return"number"==typeof t&&t>0}function ut(t){return M({name:"isPositive",validator:{validate:(t,n)=>ot(t),defaultMessage:b(t=>t+"$property must be a positive number",t)}},t)}const ct="isNegative";function lt(t){return"number"==typeof t&&t<0}function dt(t){return M({name:"isNegative",validator:{validate:(t,n)=>lt(t),defaultMessage:b(t=>t+"$property must be a negative number",t)}},t)}const pt="max";function ft(t,n){return"number"==typeof t&&"number"==typeof n&&t<=n}function mt(t,n){return M({name:"max",constraints:[t],validator:{validate:(t,n)=>ft(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must not be greater than $constraint1",n)}},n)}const gt="min";function yt(t,n){return"number"==typeof t&&"number"==typeof n&&t>=n}function vt(t,n){return M({name:"min",constraints:[t],validator:{validate:(t,n)=>yt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must not be less than $constraint1",n)}},n)}const ht="minDate";function bt(t,n){return t instanceof Date&&t.getTime()>=n.getTime()}function Mt(t,n){return M({name:"minDate",constraints:[t],validator:{validate:(t,n)=>bt(t,n.constraints[0]),defaultMessage:b(t=>"minimal allowed date for "+t+"$property is $constraint1",n)}},n)}const $t="maxDate";function It(t,n){return t instanceof Date&&t.getTime()<=n.getTime()}function Ot(t,n){return M({name:"maxDate",constraints:[t],validator:{validate:(t,n)=>It(t,n.constraints[0]),defaultMessage:b(t=>"maximal allowed date for "+t+"$property is $constraint1",n)}},n)}const Nt="contains";function At(n,e){return"string"==typeof n&&t.contains(n,e)}function St(t,n){return M({name:"contains",constraints:[t],validator:{validate:(t,n)=>At(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain a $constraint1 string",n)}},n)}const Et="notContains";function Vt(n,e){return"string"==typeof n&&!t.contains(n,e)}function wt(t,n){return M({name:"notContains",constraints:[t],validator:{validate:(t,n)=>Vt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not contain a $constraint1 string",n)}},n)}const Ct="isAlpha";function Dt(n,e){return"string"==typeof n&&t.isAlpha(n,e)}function Tt(t,n){return M({name:"isAlpha",constraints:[t],validator:{validate:(t,n)=>Dt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain only letters (a-zA-Z)",n)}},n)}const Lt="isAlphanumeric";function xt(n,e){return"string"==typeof n&&t.isAlphanumeric(n,e)}function Pt(t,n){return M({name:"isAlphanumeric",constraints:[t],validator:{validate:(t,n)=>xt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain only letters and numbers",n)}},n)}const Bt="isDecimal";function jt(n,e){return"string"==typeof n&&t.isDecimal(n,e)}function Rt(t,n){return M({name:"isDecimal",constraints:[t],validator:{validate:(t,n)=>jt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property is not a valid decimal number.",n)}},n)}const Ut="isAscii";function Ft(n){return"string"==typeof n&&t.isAscii(n)}function _t(t){return M({name:"isAscii",validator:{validate:(t,n)=>Ft(t),defaultMessage:b(t=>t+"$property must contain only ASCII characters",t)}},t)}const Ht="isBase64";function qt(n){return"string"==typeof n&&t.isBase64(n)}function kt(t){return M({name:"isBase64",validator:{validate:(t,n)=>qt(t),defaultMessage:b(t=>t+"$property must be base64 encoded",t)}},t)}const Wt="isByteLength";function zt(n,e,a){return"string"==typeof n&&t.isByteLength(n,{min:e,max:a})}function Jt(t,n,e){return M({name:"isByteLength",constraints:[t,n],validator:{validate:(t,n)=>zt(t,n.constraints[0],n.constraints[1]),defaultMessage:b(t=>t+"$property's byte length must fall into ($constraint1, $constraint2) range",e)}},e)}const Zt="isCreditCard";function Gt(n){return"string"==typeof n&&t.isCreditCard(n)}function Kt(t){return M({name:"isCreditCard",validator:{validate:(t,n)=>Gt(t),defaultMessage:b(t=>t+"$property must be a credit card",t)}},t)}const Qt="isCurrency";function Yt(n,e){return"string"==typeof n&&t.isCurrency(n,e)}function Xt(t,n){return M({name:"isCurrency",constraints:[t],validator:{validate:(t,n)=>Yt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a currency",n)}},n)}const tn="isEmail";function nn(n,e){return"string"==typeof n&&t.isEmail(n,e)}function en(t,n){return M({name:"isEmail",constraints:[t],validator:{validate:(t,n)=>nn(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an email",n)}},n)}const an="isFqdn";function rn(n,e){return"string"==typeof n&&t.isFQDN(n,e)}function sn(t,n){return M({name:"isFqdn",constraints:[t],validator:{validate:(t,n)=>rn(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid domain name",n)}},n)}const on="isFullWidth";function un(n){return"string"==typeof n&&t.isFullWidth(n)}function cn(t){return M({name:"isFullWidth",validator:{validate:(t,n)=>un(t),defaultMessage:b(t=>t+"$property must contain a full-width characters",t)}},t)}const ln="isHalfWidth";function dn(n){return"string"==typeof n&&t.isHalfWidth(n)}function pn(t){return M({name:"isHalfWidth",validator:{validate:(t,n)=>dn(t),defaultMessage:b(t=>t+"$property must contain a half-width characters",t)}},t)}const fn="isVariableWidth";function mn(n){return"string"==typeof n&&t.isVariableWidth(n)}function gn(t){return M({name:"isVariableWidth",validator:{validate:(t,n)=>mn(t),defaultMessage:b(t=>t+"$property must contain a full-width and half-width characters",t)}},t)}const yn="isHexColor";function vn(n){return"string"==typeof n&&t.isHexColor(n)}function hn(t){return M({name:"isHexColor",validator:{validate:(t,n)=>vn(t),defaultMessage:b(t=>t+"$property must be a hexadecimal color",t)}},t)}const bn="isHexadecimal";function Mn(n){return"string"==typeof n&&t.isHexadecimal(n)}function $n(t){return M({name:"isHexadecimal",validator:{validate:(t,n)=>Mn(t),defaultMessage:b(t=>t+"$property must be a hexadecimal number",t)}},t)}function In(t){return!!t&&("each"in t||"message"in t||"groups"in t||"always"in t||"context"in t)}const On="isMacAddress";function Nn(n,e){return"string"==typeof n&&t.isMACAddress(n,e)}function An(t,n){const e=In(t)?void 0:t,a=In(t)?t:n;return M({name:"isMacAddress",constraints:[e],validator:{validate:(t,n)=>Nn(t,e),defaultMessage:b(t=>t+"$property must be a MAC Address",a)}},a)}const Sn="isIp";function En(n,e){const a=e?`${e}`:void 0;return"string"==typeof n&&t.isIP(n,a)}function Vn(t,n){return M({name:"isIp",constraints:[t],validator:{validate:(t,n)=>En(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an ip address",n)}},n)}const wn="isPort";function Cn(n){return"string"==typeof n&&t.isPort(n)}function Dn(t){return M({name:"isPort",validator:{validate:(t,n)=>Cn(t),defaultMessage:b(t=>t+"$property must be a port",t)}},t)}const Tn="isIsbn";function Ln(n,e){const a=e?`${e}`:void 0;return"string"==typeof n&&t.isISBN(n,a)}function xn(t,n){return M({name:"isIsbn",constraints:[t],validator:{validate:(t,n)=>Ln(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an ISBN",n)}},n)}const Pn="isIsin";function Bn(n){return"string"==typeof n&&t.isISIN(n)}function jn(t){return M({name:"isIsin",validator:{validate:(t,n)=>Bn(t),defaultMessage:b(t=>t+"$property must be an ISIN (stock/security identifier)",t)}},t)}const Rn="isIso8601";function Un(n,e){return"string"==typeof n&&t.isISO8601(n,e)}function Fn(t,n){return M({name:"isIso8601",constraints:[t],validator:{validate:(t,n)=>Un(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid ISO 8601 date string",n)}},n)}const _n="isJson";function Hn(n){return"string"==typeof n&&t.isJSON(n)}function qn(t){return M({name:"isJson",validator:{validate:(t,n)=>Hn(t),defaultMessage:b(t=>t+"$property must be a json string",t)}},t)}const kn="isJwt";function Wn(n){return"string"==typeof n&&t.isJWT(n)}function zn(t){return M({name:"isJwt",validator:{validate:(t,n)=>Wn(t),defaultMessage:b(t=>t+"$property must be a jwt string",t)}},t)}const Jn="isLowercase";function Zn(n){return"string"==typeof n&&t.isLowercase(n)}function Gn(t){return M({name:"isLowercase",validator:{validate:(t,n)=>Zn(t),defaultMessage:b(t=>t+"$property must be a lowercase string",t)}},t)}const Kn="isMobilePhone";function Qn(n,e,a){return"string"==typeof n&&t.isMobilePhone(n,e,a)}function Yn(t,n,e){return M({name:"isMobilePhone",constraints:[t,n],validator:{validate:(t,n)=>Qn(t,n.constraints[0],n.constraints[1]),defaultMessage:b(t=>t+"$property must be a phone number",e)}},e)}const Xn="isISO31661Alpha2";function te(n){return"string"==typeof n&&t.isISO31661Alpha2(n)}function ne(t){return M({name:"isISO31661Alpha2",validator:{validate:(t,n)=>te(t),defaultMessage:b(t=>t+"$property must be a valid ISO31661 Alpha2 code",t)}},t)}const ee="isISO31661Alpha3";function ae(n){return"string"==typeof n&&t.isISO31661Alpha3(n)}function re(t){return M({name:"isISO31661Alpha3",validator:{validate:(t,n)=>ae(t),defaultMessage:b(t=>t+"$property must be a valid ISO31661 Alpha3 code",t)}},t)}const ie="isMongoId";function se(n){return"string"==typeof n&&t.isMongoId(n)}function oe(t){return M({name:"isMongoId",validator:{validate:(t,n)=>se(t),defaultMessage:b(t=>t+"$property must be a mongodb id",t)}},t)}const ue="isMultibyte";function ce(n){return"string"==typeof n&&t.isMultibyte(n)}function le(t){return M({name:"isMultibyte",validator:{validate:(t,n)=>ce(t),defaultMessage:b(t=>t+"$property must contain one or more multibyte chars",t)}},t)}const de="isSurrogatePair";function pe(n){return"string"==typeof n&&t.isSurrogatePair(n)}function fe(t){return M({name:"isSurrogatePair",validator:{validate:(t,n)=>pe(t),defaultMessage:b(t=>t+"$property must contain any surrogate pairs chars",t)}},t)}const me="isUrl";function ge(n,e){return"string"==typeof n&&t.isURL(n,e)}function ye(t,n){return M({name:"isUrl",constraints:[t],validator:{validate:(t,n)=>ge(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an URL address",n)}},n)}const ve="isUuid";function he(n,e){return"string"==typeof n&&t.isUUID(n,e)}function be(t,n){return M({name:"isUuid",constraints:[t],validator:{validate:(t,n)=>he(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an UUID",n)}},n)}const Me="IsFirebasePushId";function $e(t){return"string"==typeof t&&20===t.length&&/^[a-zA-Z0-9_-]*$/.test(t)}function Ie(t){return M({name:"IsFirebasePushId",validator:{validate:(t,n)=>$e(t),defaultMessage:b(t=>t+"$property must be a Firebase Push Id",t)}},t)}const Oe="isUppercase";function Ne(n){return"string"==typeof n&&t.isUppercase(n)}function Ae(t){return M({name:"isUppercase",validator:{validate:(t,n)=>Ne(t),defaultMessage:b(t=>t+"$property must be uppercase",t)}},t)}const Se="length";function Ee(n,e,a){return"string"==typeof n&&t.isLength(n,{min:e,max:a})}function Ve(t,n,e){return M({name:"length",constraints:[t,n],validator:{validate:(t,n)=>Ee(t,n.constraints[0],n.constraints[1]),defaultMessage:b((t,n)=>{const e=null!==n.constraints[0]&&void 0!==n.constraints[0],a=null!==n.constraints[1]&&void 0!==n.constraints[1];return e&&(!n.value||n.value.length<n.constraints[0])?t+"$property must be longer than or equal to $constraint1 characters":a&&n.value.length>n.constraints[1]?t+"$property must be shorter than or equal to $constraint2 characters":t+"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters"},e)}},e)}const we="maxLength";function Ce(n,e){return"string"==typeof n&&t.isLength(n,{min:0,max:e})}function De(t,n){return M({name:"maxLength",constraints:[t],validator:{validate:(t,n)=>Ce(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be shorter than or equal to $constraint1 characters",n)}},n)}const Te="minLength";function Le(n,e){return"string"==typeof n&&t.isLength(n,{min:e})}function xe(t,n){return M({name:"minLength",constraints:[t],validator:{validate:(t,n)=>Le(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be longer than or equal to $constraint1 characters",n)}},n)}const Pe="matches";function Be(n,e,a){return"string"==typeof n&&t.matches(n,e,a)}function je(t,n,e){let a;return n&&n instanceof Object&&!e?e=n:a=n,M({name:"matches",constraints:[t,a],validator:{validate:(t,n)=>Be(t,n.constraints[0],n.constraints[0]),defaultMessage:b((t,n)=>t+"$property must match $constraint1 regular expression",e)}},e)}const Re="isPhoneNumber";function Ue(t,e){const a=n.getInstance();try{const n=a.parseAndKeepRawInput(t,e);return a.isValidNumber(n)}catch(t){return!1}}function Fe(t,n){return M({name:"isPhoneNumber",constraints:[t],validator:{validate:(t,n)=>Ue(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid phone number",n)}},n)}const _e="isMilitaryTime";function He(n){return"string"==typeof n&&t.matches(n,/^([01]\d|2[0-3]):?([0-5]\d)$/)}function qe(t){return M({name:"isMilitaryTime",validator:{validate:(t,n)=>He(t),defaultMessage:b(t=>t+"$property must be a valid representation of military time in the format HH:MM",t)}},t)}const ke="isHash";function We(n,e){return"string"==typeof n&&t.isHash(n,e)}function ze(t,n){return M({name:"isHash",constraints:[t],validator:{validate:(t,n)=>We(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a hash of type $constraint1",n)}},n)}const Je="isISSN";function Ze(n,e){return"string"==typeof n&&t.isISSN(n,e)}function Ge(t,n){return M({name:"isISSN",constraints:[t],validator:{validate:(t,n)=>Ze(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a ISSN",n)}},n)}const Ke="isDateString";function Qe(t){return"string"==typeof t&&/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:Z|[\+\-][0-2]\d(?:\:[0-5]\d)?)?$/g.test(t)}function Ye(t){return M({name:"isDateString",validator:{validate:(t,n)=>Qe(t),defaultMessage:b(t=>t+"$property must be a ISOString",t)}},t)}const Xe="isBooleanString";function ta(n){return"string"==typeof n&&t.isBoolean(n)}function na(t){return M({name:"isBooleanString",validator:{validate:(t,n)=>ta(t),defaultMessage:b(t=>t+"$property must be a boolean string",t)}},t)}const ea="isNumberString";function aa(n,e){return"string"==typeof n&&t.isNumeric(n,e)}function ra(t,n){return M({name:"isNumberString",constraints:[t],validator:{validate:(t,n)=>aa(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a number string",n)}},n)}const ia="isBase32";function sa(n){return"string"==typeof n&&t.isBase32(n)}function oa(t){return M({name:"isBase32",validator:{validate:(t,n)=>sa(t),defaultMessage:b(t=>t+"$property must be base32 encoded",t)}},t)}const ua="isBIC";function ca(n){return"string"==typeof n&&t.isBIC(n)}function la(t){return M({name:"isBIC",validator:{validate:(t,n)=>ca(t),defaultMessage:b(t=>t+"$property must be a BIC or SWIFT code",t)}},t)}const da="isBtcAddress";function pa(n){return"string"==typeof n&&t.isBtcAddress(n)}function fa(t){return M({name:"isBtcAddress",validator:{validate:(t,n)=>pa(t),defaultMessage:b(t=>t+"$property must be a BTC address",t)}},t)}const ma="isDataURI";function ga(n){return"string"==typeof n&&t.isDataURI(n)}function ya(t){return M({name:"isDataURI",validator:{validate:(t,n)=>ga(t),defaultMessage:b(t=>t+"$property must be a data uri format",t)}},t)}const va="isEAN";function ha(n){return"string"==typeof n&&t.isEAN(n)}function ba(t){return M({name:"isEAN",validator:{validate:(t,n)=>ha(t),defaultMessage:b(t=>t+"$property must be an EAN (European Article Number)",t)}},t)}const Ma="isEthereumAddress";function $a(n){return"string"==typeof n&&t.isEthereumAddress(n)}function Ia(t){return M({name:"isEthereumAddress",validator:{validate:(t,n)=>$a(t),defaultMessage:b(t=>t+"$property must be an Ethereum address",t)}},t)}const Oa="isHSL";function Na(n){return"string"==typeof n&&t.isHSL(n)}function Aa(t){return M({name:"isHSL",validator:{validate:(t,n)=>Na(t),defaultMessage:b(t=>t+"$property must be a HSL color",t)}},t)}const Sa="isIBAN";function Ea(n){return"string"==typeof n&&t.isIBAN(n)}function Va(t){return M({name:"isIBAN",validator:{validate:(t,n)=>Ea(t),defaultMessage:b(t=>t+"$property must be an IBAN",t)}},t)}const wa="isIdentityCard";function Ca(n,e){return"string"==typeof n&&t.isIdentityCard(n,e)}function Da(t,n){return M({name:"isIdentityCard",constraints:[t],validator:{validate:(t,n)=>Ca(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a identity card number",n)}},n)}const Ta="isISRC";function La(n){return"string"==typeof n&&t.isISRC(n)}function xa(t){return M({name:"isISRC",validator:{validate:(t,n)=>La(t),defaultMessage:b(t=>t+"$property must be an ISRC",t)}},t)}const Pa="isLocale";function Ba(n){return"string"==typeof n&&t.isLocale(n)}function ja(t){return M({name:"isLocale",validator:{validate:(t,n)=>Ba(t),defaultMessage:b(t=>t+"$property must be locale",t)}},t)}const Ra="isMagnetURI";function Ua(n){return"string"==typeof n&&t.isMagnetURI(n)}function Fa(t){return M({name:"isMagnetURI",validator:{validate:(t,n)=>Ua(t),defaultMessage:b(t=>t+"$property must be magnet uri format",t)}},t)}const _a="isMimeType";function Ha(n){return"string"==typeof n&&t.isMimeType(n)}function qa(t){return M({name:"isMimeType",validator:{validate:(t,n)=>Ha(t),defaultMessage:b(t=>t+"$property must be MIME type format",t)}},t)}const ka="isOctal";function Wa(n){return"string"==typeof n&&t.isOctal(n)}function za(t){return M({name:"isOctal",validator:{validate:(t,n)=>Wa(t),defaultMessage:b(t=>t+"$property must be valid octal number",t)}},t)}const Ja="isPassportNumber";function Za(n,e){return"string"==typeof n&&t.isPassportNumber(n,e)}function Ga(t,n){return M({name:"isPassportNumber",constraints:[t],validator:{validate:(t,n)=>Za(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be valid passport number",n)}},n)}const Ka="isPostalCode";function Qa(n,e){return"string"==typeof n&&t.isPostalCode(n,e)}function Ya(t,n){return M({name:"isPostalCode",constraints:[t],validator:{validate:(t,n)=>Qa(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a postal code",n)}},n)}const Xa="isRFC3339";function tr(n){return"string"==typeof n&&t.isRFC3339(n)}function nr(t){return M({name:"isRFC3339",validator:{validate:(t,n)=>tr(t),defaultMessage:b(t=>t+"$property must be RFC 3339 date",t)}},t)}const er="isRgbColor";function ar(n,e){return"string"==typeof n&&t.isRgbColor(n,e)}function rr(t,n){return M({name:"isRgbColor",constraints:[t],validator:{validate:(t,n)=>ar(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be RGB color",n)}},n)}const ir="isSemVer";function sr(n){return"string"==typeof n&&t.isSemVer(n)}function or(t){return M({name:"isSemVer",validator:{validate:(t,n)=>sr(t),defaultMessage:b(t=>t+"$property must be a Semantic Versioning Specification",t)}},t)}const ur="isBoolean";function cr(t){return t instanceof Boolean||"boolean"==typeof t}function lr(t){return M({name:"isBoolean",validator:{validate:(t,n)=>cr(t),defaultMessage:b(t=>t+"$property must be a boolean value",t)}},t)}const dr="isDate";function pr(t){return t instanceof Date&&!isNaN(t.getTime())}function fr(t){return M({name:"isDate",validator:{validate:(t,n)=>pr(t),defaultMessage:b(t=>t+"$property must be a Date instance",t)}},t)}const mr="isNumber";function gr(t,n={}){if("number"!=typeof t)return!1;if(t===1/0||t===-1/0)return n.allowInfinity;if(Number.isNaN(t))return n.allowNaN;if(void 0!==n.maxDecimalPlaces){let e=0;if(t%1!=0&&(e=t.toString().split(".")[1].length),e>n.maxDecimalPlaces)return!1}return Number.isFinite(t)}function yr(t={},n){return M({name:"isNumber",constraints:[t],validator:{validate:(t,n)=>gr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a number conforming to the specified constraints",n)}},n)}const vr="isEnum";function hr(t,n){return Object.keys(n).map(t=>n[t]).indexOf(t)>=0}function br(t,n){return M({name:"isEnum",constraints:[t],validator:{validate:(t,n)=>hr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid enum value",n)}},n)}const Mr="isInt";function $r(t){return"number"==typeof t&&Number.isInteger(t)}function Ir(t){return M({name:"isInt",validator:{validate:(t,n)=>$r(t),defaultMessage:b(t=>t+"$property must be an integer number",t)}},t)}const Or="isString";function Nr(t){return t instanceof String||"string"==typeof t}function Ar(t){return M({name:"isString",validator:{validate:(t,n)=>Nr(t),defaultMessage:b(t=>t+"$property must be a string",t)}},t)}const Sr="isArray";function Er(t){return t instanceof Array}function Vr(t){return M({name:"isArray",validator:{validate:(t,n)=>Er(t),defaultMessage:b(t=>t+"$property must be an array",t)}},t)}const wr="isObject";function Cr(t){return null!=t&&("object"==typeof t||"function"==typeof t)&&!Array.isArray(t)}function Dr(t){return M({name:"isObject",validator:{validate:(t,n)=>Cr(t),defaultMessage:b(t=>t+"$property must be an object",t)}},t)}const Tr="arrayContains";function Lr(t,n){return t instanceof Array&&n.every(n=>-1!==t.indexOf(n))}function xr(t,n){return M({name:"arrayContains",constraints:[t],validator:{validate:(t,n)=>Lr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain $constraint1 values",n)}},n)}const Pr="arrayNotContains";function Br(t,n){return t instanceof Array&&n.every(n=>-1===t.indexOf(n))}function jr(t,n){return M({name:"arrayNotContains",constraints:[t],validator:{validate:(t,n)=>Br(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not contain $constraint1 values",n)}},n)}const Rr="arrayNotEmpty";function Ur(t){return t instanceof Array&&t.length>0}function Fr(t){return M({name:"arrayNotEmpty",validator:{validate:(t,n)=>Ur(t),defaultMessage:b(t=>t+"$property should not be empty",t)}},t)}const _r="arrayMinSize";function Hr(t,n){return t instanceof Array&&t.length>=n}function qr(t,n){return M({name:"arrayMinSize",constraints:[t],validator:{validate:(t,n)=>Hr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain at least $constraint1 elements",n)}},n)}const kr="arrayMaxSize";function Wr(t,n){return t instanceof Array&&t.length<=n}function zr(t,n){return M({name:"arrayMaxSize",constraints:[t],validator:{validate:(t,n)=>Wr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain not more than $constraint1 elements",n)}},n)}const Jr="arrayUnique";function Zr(t){if(!(t instanceof Array))return!1;const n=t.filter((t,n,e)=>e.indexOf(t)===n);return t.length===n.length}function Gr(t){return M({name:"arrayUnique",validator:{validate:(t,n)=>Zr(t),defaultMessage:b(t=>t+"All $property's elements must be unique",t)}},t)}const Kr="isNotEmptyObject";function Qr(t){if(!Cr(t))return!1;for(const n in t)if(t.hasOwnProperty(n))return!0;return!1}function Yr(t){return M({name:"isNotEmptyObject",validator:{validate:(t,n)=>Qr(t),defaultMessage:b(t=>t+"$property must be a non-empty object",t)}},t)}const Xr="isInstance";function ti(t,n){return n&&"function"==typeof n&&t instanceof n}function ni(t,n){return M({name:"isInstance",constraints:[t],validator:{validate:(t,n)=>ti(t,n.constraints[0]),defaultMessage:b((t,n)=>n.constraints[0]?t+`$property must be an instance of ${n.constraints[0].name}`:t+"isInstance decorator expects and object as value, but got falsy value.",n)}},n)}function ei(t,n,e){return"string"==typeof t?g(l).validate(t,n,e):g(l).validate(t,n)}function ai(t,n,e){return"string"==typeof t?g(l).validateOrReject(t,n,e):g(l).validateOrReject(t,n)}function ri(t,n,e){return"string"==typeof t?g(l).validateSync(t,n,e):g(l).validateSync(t,n)}function ii(t){r().addValidationSchema(t)}export{Tr as ARRAY_CONTAINS,kr as ARRAY_MAX_SIZE,_r as ARRAY_MIN_SIZE,Pr as ARRAY_NOT_CONTAINS,Rr as ARRAY_NOT_EMPTY,Jr as ARRAY_UNIQUE,y as Allow,xr as ArrayContains,zr as ArrayMaxSize,qr as ArrayMinSize,jr as ArrayNotContains,Fr as ArrayNotEmpty,Gr as ArrayUnique,Nt as CONTAINS,St as Contains,U as EQUALS,_ as Equals,Ct as IS_ALPHA,Lt as IS_ALPHANUMERIC,Sr as IS_ARRAY,Ut as IS_ASCII,ia as IS_BASE32,Ht as IS_BASE64,ua as IS_BIC,ur as IS_BOOLEAN,Xe as IS_BOOLEAN_STRING,da as IS_BTC_ADDRESS,Wt as IS_BYTE_LENGTH,Zt as IS_CREDIT_CARD,Qt as IS_CURRENCY,ma as IS_DATA_URI,dr as IS_DATE,Ke as IS_DATE_STRING,Bt as IS_DECIMAL,$ as IS_DEFINED,at as IS_DIVISIBLE_BY,va as IS_EAN,tn as IS_EMAIL,W as IS_EMPTY,vr as IS_ENUM,Ma as IS_ETHEREUM_ADDRESS,Me as IS_FIREBASE_PUSH_ID,an as IS_FQDN,on as IS_FULL_WIDTH,ln as IS_HALF_WIDTH,ke as IS_HASH,bn as IS_HEXADECIMAL,yn as IS_HEX_COLOR,Oa as IS_HSL,Sa as IS_IBAN,wa as IS_IDENTITY_CARD,Q as IS_IN,Xr as IS_INSTANCE,Mr as IS_INT,Sn as IS_IP,Tn as IS_ISBN,Pn as IS_ISIN,Xn as IS_ISO31661_ALPHA_2,ee as IS_ISO31661_ALPHA_3,Rn as IS_ISO8601,Ta as IS_ISRC,Je as IS_ISSN,_n as IS_JSON,kn as IS_JWT,L as IS_LATITUDE,C as IS_LATLONG,Pa as IS_LOCALE,B as IS_LONGITUDE,Jn as IS_LOWERCASE,On as IS_MAC_ADDRESS,Ra as IS_MAGNET_URI,_e as IS_MILITARY_TIME,_a as IS_MIME_TYPE,Kn as IS_MOBILE_PHONE,ie as IS_MONGO_ID,ue as IS_MULTIBYTE,ct as IS_NEGATIVE,Z as IS_NOT_EMPTY,Kr as IS_NOT_EMPTY_OBJECT,tt as IS_NOT_IN,mr as IS_NUMBER,ea as IS_NUMBER_STRING,wr as IS_OBJECT,ka as IS_OCTAL,Ja as IS_PASSPORT_NUMBER,Re as IS_PHONE_NUMBER,wn as IS_PORT,st as IS_POSITIVE,Ka as IS_POSTAL_CODE,Xa as IS_RFC_3339,er as IS_RGB_COLOR,ir as IS_SEM_VER,Or as IS_STRING,de as IS_SURROGATE_PAIR,Oe as IS_UPPERCASE,me as IS_URL,ve as IS_UUID,fn as IS_VARIABLE_WIDTH,Tt as IsAlpha,Pt as IsAlphanumeric,Vr as IsArray,_t as IsAscii,la as IsBIC,oa as IsBase32,kt as IsBase64,lr as IsBoolean,na as IsBooleanString,fa as IsBtcAddress,Jt as IsByteLength,Kt as IsCreditCard,Xt as IsCurrency,ya as IsDataURI,fr as IsDate,Ye as IsDateString,Rt as IsDecimal,O as IsDefined,it as IsDivisibleBy,ba as IsEAN,en as IsEmail,J as IsEmpty,br as IsEnum,Ia as IsEthereumAddress,sn as IsFQDN,Ie as IsFirebasePushId,cn as IsFullWidth,Aa as IsHSL,pn as IsHalfWidth,ze as IsHash,hn as IsHexColor,$n as IsHexadecimal,Va as IsIBAN,Vn as IsIP,xn as IsISBN,jn as IsISIN,ne as IsISO31661Alpha2,re as IsISO31661Alpha3,Fn as IsISO8601,xa as IsISRC,Ge as IsISSN,Da as IsIdentityCard,X as IsIn,ni as IsInstance,Ir as IsInt,qn as IsJSON,zn as IsJWT,T as IsLatLong,P as IsLatitude,ja as IsLocale,R as IsLongitude,Gn as IsLowercase,An as IsMACAddress,Fa as IsMagnetURI,qe as IsMilitaryTime,qa as IsMimeType,Yn as IsMobilePhone,oe as IsMongoId,le as IsMultibyte,dt as IsNegative,K as IsNotEmpty,Yr as IsNotEmptyObject,et as IsNotIn,yr as IsNumber,ra as IsNumberString,Dr as IsObject,za as IsOctal,N as IsOptional,Ga as IsPassportNumber,Fe as IsPhoneNumber,Dn as IsPort,ut as IsPositive,Ya as IsPostalCode,nr as IsRFC3339,rr as IsRgbColor,or as IsSemVer,Ar as IsString,fe as IsSurrogatePair,be as IsUUID,Ae as IsUppercase,ye as IsUrl,gn as IsVariableWidth,Se as LENGTH,Ve as Length,Pe as MATCHES,pt as MAX,$t as MAX_DATE,we as MAX_LENGTH,gt as MIN,ht as MIN_DATE,Te as MIN_LENGTH,je as Matches,mt as Max,Ot as MaxDate,De as MaxLength,i as MetadataStorage,vt as Min,Mt as MinDate,xe as MinLength,Et as NOT_CONTAINS,H as NOT_EQUALS,wt as NotContains,k as NotEquals,S as Validate,M as ValidateBy,E as ValidateIf,V as ValidateNested,w as ValidatePromise,s as ValidationError,o as ValidationTypes,l as Validator,A as ValidatorConstraint,Lr as arrayContains,Wr as arrayMaxSize,Hr as arrayMinSize,Br as arrayNotContains,Ur as arrayNotEmpty,Zr as arrayUnique,b as buildMessage,At as contains,F as equals,g as getFromContainer,r as getMetadataStorage,Dt as isAlpha,xt as isAlphanumeric,Er as isArray,Ft as isAscii,ca as isBIC,sa as isBase32,qt as isBase64,cr as isBoolean,ta as isBooleanString,pa as isBtcAddress,zt as isByteLength,Gt as isCreditCard,Yt as isCurrency,ga as isDataURI,pr as isDate,Qe as isDateString,jt as isDecimal,I as isDefined,rt as isDivisibleBy,ha as isEAN,nn as isEmail,z as isEmpty,hr as isEnum,$a as isEthereumAddress,rn as isFQDN,$e as isFirebasePushId,un as isFullWidth,Na as isHSL,dn as isHalfWidth,We as isHash,vn as isHexColor,Mn as isHexadecimal,Ea as isIBAN,En as isIP,Ln as isISBN,Bn as isISIN,te as isISO31661Alpha2,ae as isISO31661Alpha3,Un as isISO8601,La as isISRC,Ze as isISSN,Ca as isIdentityCard,Y as isIn,ti as isInstance,$r as isInt,Hn as isJSON,Wn as isJWT,D as isLatLong,x as isLatitude,Ba as isLocale,j as isLongitude,Zn as isLowercase,Nn as isMACAddress,Ua as isMagnetURI,He as isMilitaryTime,Ha as isMimeType,Qn as isMobilePhone,se as isMongoId,ce as isMultibyte,lt as isNegative,G as isNotEmpty,Qr as isNotEmptyObject,nt as isNotIn,gr as isNumber,aa as isNumberString,Cr as isObject,Wa as isOctal,Za as isPassportNumber,Ue as isPhoneNumber,Cn as isPort,ot as isPositive,Qa as isPostalCode,tr as isRFC3339,ar as isRgbColor,sr as isSemVer,Nr as isString,pe as isSurrogatePair,ge as isURL,he as isUUID,Ne as isUppercase,In as isValidationOptions,mn as isVariableWidth,Ee as length,Be as matches,ft as max,It as maxDate,Ce as maxLength,yt as min,bt as minDate,Le as minLength,Vt as notContains,q as notEquals,h as registerDecorator,ii as registerSchema,m as useContainer,ei as validate,ai as validateOrReject,ri as validateSync};
 //# sourceMappingURL=index.esm.min.js.map
diff --git a/node_modules/class-validator/bundles/index.esm.min.js.map b/node_modules/class-validator/bundles/index.esm.min.js.map
index 3d5d710..afdd6a9 100644
--- a/node_modules/class-validator/bundles/index.esm.min.js.map
+++ b/node_modules/class-validator/bundles/index.esm.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.esm.min.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/ValidationUtils.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/decorator/common/Allow.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["ValidationMetadata","[object Object]","args","this","undefined","type","target","propertyName","constraints","constraintCls","validationTypeOptions","validationOptions","message","groups","always","each","context","ValidationSchemaToMetadataTransformer","schema","metadatas","Object","keys","properties","forEach","property","validation","name","options","push","getMetadataStorage","window","global","classValidatorMetadataStorage","MetadataStorage","hasValidationMetaData","validationMetadatas","length","transform","validationMetadata","addValidationMetadata","metadata","constraintMetadatas","grouped","targetConstructor","targetSchema","originalMetadatas","filter","find","group","indexOf","uniqueInheritedMetadatas","Function","prototype","inheritedMetadata","originalMetadata","concat","ValidationError","shouldDecorate","hasParent","parentPath","boldStart","boldEnd","propConstraintFailed","join","formattedProperty","Number","isInteger","children","map","childError","toString","constructor","ValidationTypes","key","isPromise","p","then","ValidationExecutor","validator","validatorOptions","object","validationErrors","metadataStorage","console","warn","targetMetadatas","getTargetValidationMetadatas","groupedMetadatas","groupByPropertyName","forbidUnknownValues","validationError","value","unknownValue","whitelist","definedMetadatas","IS_DEFINED","WHITELIST","Promise","PROMISE_VALIDATION","awaitingPromises","resolvedValue","performValidations","notAllowedProperties","forbidNonWhitelisted","generateValidationError","errors","error","stripEmptyErrors","customValidationMetadatas","CUSTOM_VALIDATION","nestedValidationMetadatas","NESTED_VALIDATION","conditionalValidationMetadatas","CONDITIONAL_VALIDATION","conditionalValidations","customValidations","mapContexts","skipUndefinedProperties","skipNullProperties","skipMissingProperties","nestedValidations","reduce","resultA","resultB","getTargetValidatorConstraints","customConstraintMetadata","async","ignoreAsyncValidations","validationArguments","targetName","Array","Set","Map","validatedValue","instance","validate","promise","isValid","createValidationError","contexts","assign","val","validatedSubValues","from","values","isArray","subValue","some","validatedSubValue","asyncValidatedSubValues","resolve","asyncValidationIsFinishedPromise","all","flatValidatedValues","every","index","execute","customConstraint","getConstraintType","customValidatorMetadata","dismissDefaultMessages","defaultMessage","messageString","constraint","replace","RegExp","replaceMessageSpecialTokens","Validator","objectOrSchemaName","objectOrValidationOptions","maybeValidatorOptions","executor","coreValidate","reject","defaultContainer","someClass","instances","userContainer","userContainerOptions","useContainer","iocContainer","getFromContainer","get","fallback","fallbackOnErrors","Allow","ConstraintMetadata","registerDecorator","addConstraintMetadata","validationMetadataArgs","buildMessage","impl","eachPrefix","ValidateBy","isDefined","IsDefined","IsOptional","ValidatorConstraint","isAsync","x","y","toLowerCase","Validate","constraintClass","constraintsOrValidationOptions","maybeValidationOptions","ValidateIf","condition","ValidateNested","opts","ValidatePromise","IS_LATLONG","isLatLong","IsLatLong","IS_LATITUDE","isLatitude","IsLatitude","IS_LONGITUDE","isLongitude","IsLongitude","EQUALS","equals","comparison","Equals","NOT_EQUALS","notEquals","NotEquals","IS_EMPTY","isEmpty","IsEmpty","IS_NOT_EMPTY","isNotEmpty","IsNotEmpty","IS_IN","isIn","possibleValues","possibleValue","IsIn","IS_NOT_IN","isNotIn","IsNotIn","IS_DIVISIBLE_BY","isDivisibleBy","num","String","IsDivisibleBy","IS_POSITIVE","isPositive","IsPositive","IS_NEGATIVE","isNegative","IsNegative","MAX","max","Max","maxValue","MIN","min","Min","minValue","MIN_DATE","minDate","date","Date","getTime","MinDate","MAX_DATE","maxDate","MaxDate","CONTAINS","contains","seed","Contains","NOT_CONTAINS","notContains","NotContains","IS_ALPHA","isAlpha","locale","ValidatorJS","IsAlpha","IS_ALPHANUMERIC","isAlphanumeric","IsAlphanumeric","IS_DECIMAL","isDecimal","IsDecimal","IS_ASCII","isAscii","IsAscii","IS_BASE64","isBase64","IsBase64","IS_BYTE_LENGTH","isByteLength","IsByteLength","IS_CREDIT_CARD","isCreditCard","IsCreditCard","IS_CURRENCY","isCurrency","IsCurrency","IS_EMAIL","isEmail","IsEmail","IS_FQDN","isFQDN","IsFQDN","IS_FULL_WIDTH","isFullWidth","IsFullWidth","IS_HALF_WIDTH","isHalfWidth","IsHalfWidth","IS_VARIABLE_WIDTH","isVariableWidth","IsVariableWidth","IS_HEX_COLOR","isHexColor","IsHexColor","IS_HEXADECIMAL","isHexadecimal","IsHexadecimal","isValidationOptions","IS_MAC_ADDRESS","isMACAddress","IsMACAddress","optionsOrValidationOptionsArg","validationOptionsArg","IS_IP","isIP","version","versionStr","IsIP","IS_PORT","isPort","IsPort","IS_ISBN","isISBN","IsISBN","IS_ISIN","isISIN","IsISIN","IS_ISO8601","isISO8601","IsISO8601","IS_JSON","isJSON","IsJSON","IS_JWT","isJWT","IsJWT","IS_LOWERCASE","isLowercase","IsLowercase","IS_MOBILE_PHONE","isMobilePhone","IsMobilePhone","IS_ISO31661_ALPHA_2","isISO31661Alpha2","IsISO31661Alpha2","IS_ISO31661_ALPHA_3","isISO31661Alpha3","IsISO31661Alpha3","IS_MONGO_ID","isMongoId","IsMongoId","IS_MULTIBYTE","isMultibyte","IsMultibyte","IS_SURROGATE_PAIR","isSurrogatePair","IsSurrogatePair","IS_URL","isURL","IsUrl","IS_UUID","isUUID","IsUUID","IS_FIREBASE_PUSH_ID","isFirebasePushId","test","IsFirebasePushId","IS_UPPERCASE","isUppercase","IsUppercase","LENGTH","isLength","Length","isMinLength","isMaxLength","MAX_LENGTH","maxLength","MaxLength","MIN_LENGTH","minLength","MinLength","MATCHES","matches","pattern","modifiers","Matches","modifiersOrAnnotationOptions","IS_PHONE_NUMBER","isPhoneNumber","region","phoneUtil","PhoneNumberUtil","getInstance","phoneNum","parseAndKeepRawInput","isValidNumber","IsPhoneNumber","IS_MILITARY_TIME","isMilitaryTime","IsMilitaryTime","IS_HASH","isHash","algorithm","IsHash","IS_ISSN","isISSN","IsISSN","IS_DATE_STRING","isDateString","IsDateString","IS_BOOLEAN_STRING","isBooleanString","isBoolean","IsBooleanString","IS_NUMBER_STRING","isNumberString","isNumeric","IsNumberString","IS_BASE32","isBase32","IsBase32","IS_BIC","isBIC","IsBIC","IS_BTC_ADDRESS","isBtcAddress","IsBtcAddress","IS_DATA_URI","isDataURI","IsDataURI","IS_EAN","isEAN","IsEAN","IS_ETHEREUM_ADDRESS","isEthereumAddress","IsEthereumAddress","IS_HSL","isHSL","IsHSL","IS_IBAN","isIBAN","IsIBAN","IS_IDENTITY_CARD","isIdentityCard","IsIdentityCard","IS_ISRC","isISRC","IsISRC","IS_LOCALE","isLocale","IsLocale","IS_MAGNET_URI","isMagnetURI","IsMagnetURI","IS_MIME_TYPE","isMimeType","IsMimeType","IS_OCTAL","isOctal","IsOctal","IS_PASSPORT_NUMBER","isPassportNumber","countryCode","IsPassportNumber","IS_POSTAL_CODE","isPostalCode","IsPostalCode","IS_RFC_3339","isRFC3339","IsRFC3339","IS_RGB_COLOR","isRgbColor","includePercentValues","IsRgbColor","IS_SEM_VER","isSemVer","IsSemVer","IS_BOOLEAN","Boolean","IsBoolean","IS_DATE","isDate","isNaN","IsDate","IS_NUMBER","isNumber","Infinity","allowInfinity","allowNaN","maxDecimalPlaces","decimalPlaces","split","isFinite","IsNumber","IS_ENUM","isEnum","entity","k","IsEnum","IS_INT","isInt","IsInt","IS_STRING","isString","IsString","IS_ARRAY","IsArray","IS_OBJECT","isObject","IsObject","ARRAY_CONTAINS","arrayContains","array","ArrayContains","ARRAY_NOT_CONTAINS","arrayNotContains","ArrayNotContains","ARRAY_NOT_EMPTY","arrayNotEmpty","ArrayNotEmpty","ARRAY_MIN_SIZE","arrayMinSize","ArrayMinSize","ARRAY_MAX_SIZE","arrayMaxSize","ArrayMaxSize","ARRAY_UNIQUE","arrayUnique","uniqueItems","a","b","c","ArrayUnique","IS_NOT_EMPTY_OBJECT","isNotEmptyObject","hasOwnProperty","IsNotEmptyObject","IS_INSTANCE","isInstance","targetTypeConstructor","IsInstance","targetType","schemaNameOrObject","validateOrReject","validateSync","registerSchema","addValidationSchema"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.esm.min.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/ValidationUtils.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/decorator/common/Allow.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: string[];\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = [\"an unknown value was passed to the validate function\"];\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = [`property ${property} should not exist`];\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (error.constraints.length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = [];\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints.push(message);\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints.push(message);\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = [message];\n                errors.push(error);\n            }\n        });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["ValidationMetadata","[object Object]","args","this","undefined","type","target","propertyName","constraints","constraintCls","validationTypeOptions","validationOptions","message","groups","always","each","context","ValidationSchemaToMetadataTransformer","schema","metadatas","Object","keys","properties","forEach","property","validation","name","options","push","getMetadataStorage","window","global","classValidatorMetadataStorage","MetadataStorage","hasValidationMetaData","validationMetadatas","length","transform","validationMetadata","addValidationMetadata","metadata","constraintMetadatas","grouped","targetConstructor","targetSchema","originalMetadatas","filter","find","group","indexOf","uniqueInheritedMetadatas","Function","prototype","inheritedMetadata","originalMetadata","concat","ValidationError","shouldDecorate","hasParent","parentPath","boldStart","boldEnd","propConstraintFailed","join","formattedProperty","Number","isInteger","children","map","childError","toString","constructor","ValidationTypes","key","isPromise","p","then","ValidationExecutor","validator","validatorOptions","object","validationErrors","metadataStorage","console","warn","targetMetadatas","getTargetValidationMetadatas","groupedMetadatas","groupByPropertyName","forbidUnknownValues","validationError","value","whitelist","definedMetadatas","IS_DEFINED","WHITELIST","Promise","PROMISE_VALIDATION","awaitingPromises","resolvedValue","performValidations","notAllowedProperties","forbidNonWhitelisted","generateValidationError","errors","error","stripEmptyErrors","customValidationMetadatas","CUSTOM_VALIDATION","nestedValidationMetadatas","NESTED_VALIDATION","conditionalValidationMetadatas","CONDITIONAL_VALIDATION","conditionalValidations","customValidations","skipUndefinedProperties","skipNullProperties","skipMissingProperties","nestedValidations","reduce","resultA","resultB","getTargetValidatorConstraints","customConstraintMetadata","async","ignoreAsyncValidations","validationArguments","targetName","Array","Set","Map","validatedValue","instance","validate","promise","isValid","createValidationError","contexts","assign","val","validatedSubValues","from","values","isArray","subValue","some","validatedSubValue","asyncValidatedSubValues","resolve","asyncValidationIsFinishedPromise","all","flatValidatedValues","every","index","execute","customValidatorMetadata","getConstraintType","dismissDefaultMessages","defaultMessage","messageString","constraint","replace","RegExp","replaceMessageSpecialTokens","Validator","objectOrSchemaName","objectOrValidationOptions","maybeValidatorOptions","executor","coreValidate","reject","defaultContainer","someClass","instances","userContainer","userContainerOptions","useContainer","iocContainer","getFromContainer","get","fallback","fallbackOnErrors","Allow","ConstraintMetadata","registerDecorator","addConstraintMetadata","validationMetadataArgs","buildMessage","impl","eachPrefix","ValidateBy","isDefined","IsDefined","IsOptional","ValidatorConstraint","isAsync","x","y","toLowerCase","Validate","constraintClass","constraintsOrValidationOptions","maybeValidationOptions","ValidateIf","condition","ValidateNested","opts","ValidatePromise","IS_LATLONG","isLatLong","IsLatLong","IS_LATITUDE","isLatitude","IsLatitude","IS_LONGITUDE","isLongitude","IsLongitude","EQUALS","equals","comparison","Equals","NOT_EQUALS","notEquals","NotEquals","IS_EMPTY","isEmpty","IsEmpty","IS_NOT_EMPTY","isNotEmpty","IsNotEmpty","IS_IN","isIn","possibleValues","possibleValue","IsIn","IS_NOT_IN","isNotIn","IsNotIn","IS_DIVISIBLE_BY","isDivisibleBy","num","String","IsDivisibleBy","IS_POSITIVE","isPositive","IsPositive","IS_NEGATIVE","isNegative","IsNegative","MAX","max","Max","maxValue","MIN","min","Min","minValue","MIN_DATE","minDate","date","Date","getTime","MinDate","MAX_DATE","maxDate","MaxDate","CONTAINS","contains","seed","Contains","NOT_CONTAINS","notContains","NotContains","IS_ALPHA","isAlpha","locale","ValidatorJS","IsAlpha","IS_ALPHANUMERIC","isAlphanumeric","IsAlphanumeric","IS_DECIMAL","isDecimal","IsDecimal","IS_ASCII","isAscii","IsAscii","IS_BASE64","isBase64","IsBase64","IS_BYTE_LENGTH","isByteLength","IsByteLength","IS_CREDIT_CARD","isCreditCard","IsCreditCard","IS_CURRENCY","isCurrency","IsCurrency","IS_EMAIL","isEmail","IsEmail","IS_FQDN","isFQDN","IsFQDN","IS_FULL_WIDTH","isFullWidth","IsFullWidth","IS_HALF_WIDTH","isHalfWidth","IsHalfWidth","IS_VARIABLE_WIDTH","isVariableWidth","IsVariableWidth","IS_HEX_COLOR","isHexColor","IsHexColor","IS_HEXADECIMAL","isHexadecimal","IsHexadecimal","isValidationOptions","IS_MAC_ADDRESS","isMACAddress","IsMACAddress","optionsOrValidationOptionsArg","validationOptionsArg","IS_IP","isIP","version","versionStr","IsIP","IS_PORT","isPort","IsPort","IS_ISBN","isISBN","IsISBN","IS_ISIN","isISIN","IsISIN","IS_ISO8601","isISO8601","IsISO8601","IS_JSON","isJSON","IsJSON","IS_JWT","isJWT","IsJWT","IS_LOWERCASE","isLowercase","IsLowercase","IS_MOBILE_PHONE","isMobilePhone","IsMobilePhone","IS_ISO31661_ALPHA_2","isISO31661Alpha2","IsISO31661Alpha2","IS_ISO31661_ALPHA_3","isISO31661Alpha3","IsISO31661Alpha3","IS_MONGO_ID","isMongoId","IsMongoId","IS_MULTIBYTE","isMultibyte","IsMultibyte","IS_SURROGATE_PAIR","isSurrogatePair","IsSurrogatePair","IS_URL","isURL","IsUrl","IS_UUID","isUUID","IsUUID","IS_FIREBASE_PUSH_ID","isFirebasePushId","test","IsFirebasePushId","IS_UPPERCASE","isUppercase","IsUppercase","LENGTH","isLength","Length","isMinLength","isMaxLength","MAX_LENGTH","maxLength","MaxLength","MIN_LENGTH","minLength","MinLength","MATCHES","matches","pattern","modifiers","Matches","modifiersOrAnnotationOptions","IS_PHONE_NUMBER","isPhoneNumber","region","phoneUtil","PhoneNumberUtil","getInstance","phoneNum","parseAndKeepRawInput","isValidNumber","IsPhoneNumber","IS_MILITARY_TIME","isMilitaryTime","IsMilitaryTime","IS_HASH","isHash","algorithm","IsHash","IS_ISSN","isISSN","IsISSN","IS_DATE_STRING","isDateString","IsDateString","IS_BOOLEAN_STRING","isBooleanString","isBoolean","IsBooleanString","IS_NUMBER_STRING","isNumberString","isNumeric","IsNumberString","IS_BASE32","isBase32","IsBase32","IS_BIC","isBIC","IsBIC","IS_BTC_ADDRESS","isBtcAddress","IsBtcAddress","IS_DATA_URI","isDataURI","IsDataURI","IS_EAN","isEAN","IsEAN","IS_ETHEREUM_ADDRESS","isEthereumAddress","IsEthereumAddress","IS_HSL","isHSL","IsHSL","IS_IBAN","isIBAN","IsIBAN","IS_IDENTITY_CARD","isIdentityCard","IsIdentityCard","IS_ISRC","isISRC","IsISRC","IS_LOCALE","isLocale","IsLocale","IS_MAGNET_URI","isMagnetURI","IsMagnetURI","IS_MIME_TYPE","isMimeType","IsMimeType","IS_OCTAL","isOctal","IsOctal","IS_PASSPORT_NUMBER","isPassportNumber","countryCode","IsPassportNumber","IS_POSTAL_CODE","isPostalCode","IsPostalCode","IS_RFC_3339","isRFC3339","IsRFC3339","IS_RGB_COLOR","isRgbColor","includePercentValues","IsRgbColor","IS_SEM_VER","isSemVer","IsSemVer","IS_BOOLEAN","Boolean","IsBoolean","IS_DATE","isDate","isNaN","IsDate","IS_NUMBER","isNumber","Infinity","allowInfinity","allowNaN","maxDecimalPlaces","decimalPlaces","split","isFinite","IsNumber","IS_ENUM","isEnum","entity","k","IsEnum","IS_INT","isInt","IsInt","IS_STRING","isString","IsString","IS_ARRAY","IsArray","IS_OBJECT","isObject","IsObject","ARRAY_CONTAINS","arrayContains","array","ArrayContains","ARRAY_NOT_CONTAINS","arrayNotContains","ArrayNotContains","ARRAY_NOT_EMPTY","arrayNotEmpty","ArrayNotEmpty","ARRAY_MIN_SIZE","arrayMinSize","ArrayMinSize","ARRAY_MAX_SIZE","arrayMaxSize","ArrayMaxSize","ARRAY_UNIQUE","arrayUnique","uniqueItems","a","b","c","ArrayUnique","IS_NOT_EMPTY_OBJECT","isNotEmptyObject","hasOwnProperty","IsNotEmptyObject","IS_INSTANCE","isInstance","targetTypeConstructor","IsInstance","targetType","schemaNameOrObject","validateOrReject","validateSync","registerSchema","addValidationSchema"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/class-validator/bundles/index.umd.js b/node_modules/class-validator/bundles/index.umd.js
index 40e91a9..36be2d8 100644
--- a/node_modules/class-validator/bundles/index.umd.js
+++ b/node_modules/class-validator/bundles/index.umd.js
@@ -348,7 +348,7 @@
                 validationError.value = undefined;
                 validationError.property = undefined;
                 validationError.children = [];
-                validationError.constraints = { unknownValue: "an unknown value was passed to the validate function" };
+                validationError.constraints = ["an unknown value was passed to the validate function"];
                 validationErrors.push(validationError);
                 return;
             }
@@ -381,9 +381,8 @@
                 if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {
                     // throw errors
                     notAllowedProperties.forEach(function (property) {
-                        var _a;
                         var validationError = _this.generateValidationError(object, object[property], property);
-                        validationError.constraints = (_a = {}, _a[ValidationTypes.WHITELIST] = "property " + property + " should not exist", _a);
+                        validationError.constraints = ["property " + property + " should not exist"];
                         validationError.children = undefined;
                         validationErrors.push(validationError);
                     });
@@ -400,7 +399,7 @@
                 if (error.children) {
                     error.children = _this.stripEmptyErrors(error.children);
                 }
-                if (Object.keys(error.constraints).length === 0) {
+                if (error.constraints.length === 0) {
                     if (error.children.length === 0) {
                         return false;
                     }
@@ -426,7 +425,6 @@
             }
             // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not
             this.customValidations(object, value, definedMetadatas, validationError);
-            this.mapContexts(object, value, definedMetadatas, validationError);
             if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {
                 return;
             }
@@ -438,8 +436,6 @@
             }
             this.customValidations(object, value, customValidationMetadatas, validationError);
             this.nestedValidations(value, nestedValidationMetadatas, validationError.children);
-            this.mapContexts(object, value, metadatas, validationError);
-            this.mapContexts(object, value, customValidationMetadatas, validationError);
         };
         ValidationExecutor.prototype.generateValidationError = function (object, value, propertyName) {
             var validationError = new ValidationError();
@@ -455,7 +451,7 @@
                 validationError.value = value;
             validationError.property = propertyName;
             validationError.children = [];
-            validationError.constraints = {};
+            validationError.constraints = [];
             return validationError;
         };
         ValidationExecutor.prototype.conditionalValidations = function (object, value, metadatas) {
@@ -484,7 +480,7 @@
                             var promise = validatedValue.then(function (isValid) {
                                 if (!isValid) {
                                     var _a = _this.createValidationError(object, value, metadata, customConstraintMetadata), type = _a[0], message = _a[1];
-                                    error.constraints[type] = message;
+                                    error.constraints.push(message);
                                     if (metadata.context) {
                                         if (!error.contexts) {
                                             error.contexts = {};
@@ -498,7 +494,7 @@
                         else {
                             if (!validatedValue) {
                                 var _a = _this.createValidationError(object, value, metadata, customConstraintMetadata), type = _a[0], message = _a[1];
-                                error.constraints[type] = message;
+                                error.constraints.push(message);
                             }
                         }
                         return;
@@ -518,7 +514,7 @@
                             var validationResult = flatValidatedValues.every(function (isValid) { return isValid; });
                             if (!validationResult) {
                                 var _a = _this.createValidationError(object, value, metadata, customConstraintMetadata), type = _a[0], message = _a[1];
-                                error.constraints[type] = message;
+                                error.constraints.push(message);
                                 if (metadata.context) {
                                     if (!error.contexts) {
                                         error.contexts = {};
@@ -533,7 +529,7 @@
                     var validationResult = validatedSubValues.every(function (isValid) { return isValid; });
                     if (!validationResult) {
                         var _b = _this.createValidationError(object, value, metadata, customConstraintMetadata), type = _b[0], message = _b[1];
-                        error.constraints[type] = message;
+                        error.constraints.push(message);
                     }
                 });
             });
@@ -544,7 +540,6 @@
                 return;
             }
             metadatas.forEach(function (metadata) {
-                var _a;
                 if (metadata.type !== ValidationTypes.NESTED_VALIDATION &&
                     metadata.type !== ValidationTypes.PROMISE_VALIDATION) {
                     return;
@@ -565,34 +560,12 @@
                     error.value = value;
                     error.property = metadata.propertyName;
                     error.target = metadata.target;
-                    var _b = _this.createValidationError(metadata.target, value, metadata), type = _b[0], message = _b[1];
-                    error.constraints = (_a = {},
-                        _a[type] = message,
-                        _a);
+                    var _a = _this.createValidationError(metadata.target, value, metadata), type = _a[0], message = _a[1];
+                    error.constraints = [message];
                     errors.push(error);
                 }
             });
         };
-        ValidationExecutor.prototype.mapContexts = function (object, value, metadatas, error) {
-            var _this = this;
-            return metadatas
-                .forEach(function (metadata) {
-                if (metadata.context) {
-                    var customConstraint = void 0;
-                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {
-                        var customConstraints = _this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);
-                        customConstraint = customConstraints[0];
-                    }
-                    var type = _this.getConstraintType(metadata, customConstraint);
-                    if (error.constraints[type]) {
-                        if (!error.contexts) {
-                            error.contexts = {};
-                        }
-                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);
-                    }
-                }
-            });
-        };
         ValidationExecutor.prototype.createValidationError = function (object, value, metadata, customValidatorMetadata) {
             var targetName = object.constructor ? object.constructor.name : undefined;
             var type = this.getConstraintType(metadata, customValidatorMetadata);
diff --git a/node_modules/class-validator/bundles/index.umd.js.map b/node_modules/class-validator/bundles/index.umd.js.map
index 047cb88..bf9b16f 100644
--- a/node_modules/class-validator/bundles/index.umd.js.map
+++ b/node_modules/class-validator/bundles/index.umd.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.umd.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/validation/ValidationUtils.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/decorator/common/Allow.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["ValidatorJS","PhoneNumberUtil"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.umd.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/validation/ValidationUtils.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/decorator/common/Allow.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: string[];\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = [\"an unknown value was passed to the validate function\"];\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = [`property ${property} should not exist`];\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (error.constraints.length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = [];\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints.push(message);\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints.push(message);\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = [message];\n                errors.push(error);\n            }\n        });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["ValidatorJS","PhoneNumberUtil"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/class-validator/bundles/index.umd.min.js b/node_modules/class-validator/bundles/index.umd.min.js
index 8cea0e5..21e517f 100644
--- a/node_modules/class-validator/bundles/index.umd.min.js
+++ b/node_modules/class-validator/bundles/index.umd.min.js
@@ -1,2 +1,2 @@
-!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("tslib"),require("validator"),require("google-libphonenumber")):"function"==typeof define&&define.amd?define(["exports","tslib","validator","google-libphonenumber"],n):n((t=t||self).ClassValidator={},t.tslib_1,t.validator,t.googleLibphonenumber)}(this,function(t,i,e,a){"use strict";e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e;var o=function(t){this.groups=[],this.always=!1,this.each=!1,this.context=void 0,this.type=t.type,this.target=t.target,this.propertyName=t.propertyName,this.constraints=t.constraints,this.constraintCls=t.constraintCls,this.validationTypeOptions=t.validationTypeOptions,t.validationOptions&&(this.message=t.validationOptions.message,this.groups=t.validationOptions.groups,this.always=t.validationOptions.always,this.each=t.validationOptions.each,this.context=t.validationOptions.context)},r=(n.prototype.transform=function(a){var i=[];return Object.keys(a.properties).forEach(function(e){a.properties[e].forEach(function(t){var n={message:t.message,groups:t.groups,always:t.always,each:t.each},r={type:t.type,target:a.name,propertyName:e,constraints:t.constraints,validationTypeOptions:t.options,validationOptions:n};i.push(new o(r))})}),i},n);function n(){}function s(){return"undefined"!=typeof window&&(window.global=window),global.classValidatorMetadataStorage||(global.classValidatorMetadataStorage=new u),global.classValidatorMetadataStorage}var u=(Object.defineProperty(c.prototype,"hasValidationMetaData",{get:function(){return!!this.validationMetadatas.length},enumerable:!0,configurable:!0}),c.prototype.addValidationSchema=function(t){var n=this;(new r).transform(t).forEach(function(t){return n.addValidationMetadata(t)})},c.prototype.addValidationMetadata=function(t){this.validationMetadatas.push(t)},c.prototype.addConstraintMetadata=function(t){this.constraintMetadatas.push(t)},c.prototype.groupByPropertyName=function(t){var n={};return t.forEach(function(t){n[t.propertyName]||(n[t.propertyName]=[]),n[t.propertyName].push(t)}),n},c.prototype.getTargetValidationMetadatas=function(n,r,e){var t=this.validationMetadatas.filter(function(t){return(t.target===n||t.target===r)&&(!!t.always||!(e&&0<e.length)||t.groups&&!!t.groups.find(function(t){return-1!==e.indexOf(t)}))}),a=this.validationMetadatas.filter(function(t){return"string"!=typeof t.target&&t.target!==n&&(!(t.target instanceof Function)||n.prototype instanceof t.target)&&(!!t.always||!(e&&0<e.length)||t.groups&&!!t.groups.find(function(t){return-1!==e.indexOf(t)}))}).filter(function(n){return!t.find(function(t){return t.propertyName===n.propertyName&&t.type===n.type})});return t.concat(a)},c.prototype.getTargetValidatorConstraints=function(n){return this.constraintMetadatas.filter(function(t){return t.target===n})},c);function c(){this.validationMetadatas=[],this.constraintMetadatas=[]}var l=(f.prototype.toString=function(n,t,r){var e=this;function a(t){return" - property "+i+r+t+o+" has failed the following constraints: "+i+Object.keys(e.constraints).join(", ")+o+" \n"}void 0===n&&(n=!1),void 0===t&&(t=!1),void 0===r&&(r="");var i=n?"[1m":"",o=n?"[22m":"";if(t){var s=Number.isInteger(+this.property)?"["+this.property+"]":(r?".":"")+this.property;return this.constraints?a(s):this.children.map(function(t){return t.toString(n,!0,r+s)}).join("")}return"An instance of "+i+(this.target?this.target.constructor.name:"an object")+o+" has failed the validation:\n"+(this.constraints?a(this.property):"")+this.children.map(function(t){return t.toString(n,!0,e.property)}).join("")},f);function f(){}var d=(p.isValid=function(t){var n=this;return"isValid"!==t&&"getMessage"!==t&&-1!==Object.keys(this).map(function(t){return n[t]}).indexOf(t)},p.CUSTOM_VALIDATION="customValidation",p.NESTED_VALIDATION="nestedValidation",p.PROMISE_VALIDATION="promiseValidation",p.CONDITIONAL_VALIDATION="conditionalValidation",p.WHITELIST="whitelistValidation",p.IS_DEFINED="isDefined",p);function p(){}var v=(m.replaceMessageSpecialTokens=function(t,n){var r;return t instanceof Function?r=t(n):"string"==typeof t&&(r=t),r&&n.constraints instanceof Array&&n.constraints.forEach(function(t,n){r=r.replace(new RegExp("\\$constraint"+(n+1),"g"),t)}),r&&void 0!==n.value&&null!==n.value&&"string"==typeof n.value&&(r=r.replace(/\$value/g,n.value)),r=(r=r&&r.replace(/\$property/g,n.property))&&r.replace(/\$target/g,n.targetName)},m);function m(){}function g(t){return null!==t&&"object"==typeof t&&"function"==typeof t.then}var y=(I.prototype.execute=function(a,t,i){var o=this;this.metadataStorage.hasValidationMetaData||console.warn("No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.");var n=this.validatorOptions?this.validatorOptions.groups:void 0,r=this.metadataStorage.getTargetValidationMetadatas(a.constructor,t,n),s=this.metadataStorage.groupByPropertyName(r);if(this.validatorOptions&&this.validatorOptions.forbidUnknownValues&&!r.length){var e=new l;return this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.target&&!0!==this.validatorOptions.validationError.target||(e.target=a),e.value=void 0,e.property=void 0,e.children=[],e.constraints={unknownValue:"an unknown value was passed to the validate function"},void i.push(e)}this.validatorOptions&&this.validatorOptions.whitelist&&this.whitelist(a,s,i),Object.keys(s).forEach(function(n){var t=a[n],r=s[n].filter(function(t){return t.type===d.IS_DEFINED}),e=s[n].filter(function(t){return t.type!==d.IS_DEFINED&&t.type!==d.WHITELIST});t instanceof Promise&&e.find(function(t){return t.type===d.PROMISE_VALIDATION})?o.awaitingPromises.push(t.then(function(t){o.performValidations(a,t,n,r,e,i)})):o.performValidations(a,t,n,r,e,i)})},I.prototype.whitelist=function(e,n,a){var i=this,r=[];Object.keys(e).forEach(function(t){n[t]&&0!==n[t].length||r.push(t)}),0<r.length&&(this.validatorOptions&&this.validatorOptions.forbidNonWhitelisted?r.forEach(function(t){var n,r=i.generateValidationError(e,e[t],t);r.constraints=((n={})[d.WHITELIST]="property "+t+" should not exist",n),r.children=void 0,a.push(r)}):r.forEach(function(t){return delete e[t]}))},I.prototype.stripEmptyErrors=function(t){var n=this;return t.filter(function(t){if(t.children&&(t.children=n.stripEmptyErrors(t.children)),0===Object.keys(t.constraints).length){if(0===t.children.length)return!1;delete t.constraints}return!0})},I.prototype.performValidations=function(t,n,r,e,a,i){var o=a.filter(function(t){return t.type===d.CUSTOM_VALIDATION}),s=a.filter(function(t){return t.type===d.NESTED_VALIDATION}),u=a.filter(function(t){return t.type===d.CONDITIONAL_VALIDATION}),c=this.generateValidationError(t,n,r);i.push(c),this.conditionalValidations(t,n,u)&&(this.customValidations(t,n,e,c),this.mapContexts(t,n,e,c),void 0===n&&this.validatorOptions&&!0===this.validatorOptions.skipUndefinedProperties||null===n&&this.validatorOptions&&!0===this.validatorOptions.skipNullProperties||null==n&&this.validatorOptions&&!0===this.validatorOptions.skipMissingProperties||(this.customValidations(t,n,o,c),this.nestedValidations(n,s,c.children),this.mapContexts(t,n,a,c),this.mapContexts(t,n,o,c)))},I.prototype.generateValidationError=function(t,n,r){var e=new l;return this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.target&&!0!==this.validatorOptions.validationError.target||(e.target=t),this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.value&&!0!==this.validatorOptions.validationError.value||(e.value=n),e.property=r,e.children=[],e.constraints={},e},I.prototype.conditionalValidations=function(n,r,t){return t.map(function(t){return t.constraints[0](n,r)}).reduce(function(t,n){return t&&n},!0)},I.prototype.customValidations=function(p,v,t,m){var y=this;t.forEach(function(d){y.metadataStorage.getTargetValidatorConstraints(d.constraintCls).forEach(function(a){if(!a.async||!y.ignoreAsyncValidations){var n={targetName:p.constructor?p.constructor.name:void 0,property:d.propertyName,object:p,value:v,constraints:d.constraints};if(d.each&&(v instanceof Array||v instanceof Set||v instanceof Map)){var t,r=((t=v)instanceof Map?Array.from(t.values()):Array.isArray(t)?t:Array.from(t)).map(function(t){return a.instance.validate(t,n)});if(r.some(function(t){return g(t)})){var e=r.map(function(t){return g(t)?t:Promise.resolve(t)}),i=Promise.all(e).then(function(t){if(!t.every(function(t){return t})){var n=y.createValidationError(p,v,d,a),r=n[0],e=n[1];m.constraints[r]=e,d.context&&(m.contexts||(m.contexts={}),m.contexts[r]=Object.assign(m.contexts[r]||{},d.context))}});y.awaitingPromises.push(i)}else if(!r.every(function(t){return t})){var o=y.createValidationError(p,v,d,a);f=o[0],l=o[1],m.constraints[f]=l}}else{var s=a.instance.validate(v,n);if(g(s)){var u=s.then(function(t){if(!t){var n=y.createValidationError(p,v,d,a),r=n[0],e=n[1];m.constraints[r]=e,d.context&&(m.contexts||(m.contexts={}),m.contexts[r]=Object.assign(m.contexts[r]||{},d.context))}});y.awaitingPromises.push(u)}else if(!s){var c=y.createValidationError(p,v,d,a),f=c[0],l=c[1];m.constraints[f]=l}}}})})},I.prototype.nestedValidations=function(s,u,c){var f=this;void 0!==s&&u.forEach(function(t){var n;if(t.type===d.NESTED_VALIDATION||t.type===d.PROMISE_VALIDATION)if(s instanceof Array||s instanceof Set||s instanceof Map)(s instanceof Set?Array.from(s):s).forEach(function(t,n){f.performValidations(s,t,n.toString(),[],u,c)});else if(s instanceof Object){var r="string"==typeof t.target?t.target:t.target.name;f.execute(s,r,c)}else{var e=new l;e.value=s,e.property=t.propertyName,e.target=t.target;var a=f.createValidationError(t.target,s,t),i=a[0],o=a[1];e.constraints=((n={})[i]=o,n),c.push(e)}})},I.prototype.mapContexts=function(t,n,r,e){var a=this;return r.forEach(function(t){if(t.context){var n=void 0;t.type===d.CUSTOM_VALIDATION&&(n=a.metadataStorage.getTargetValidatorConstraints(t.constraintCls)[0]);var r=a.getConstraintType(t,n);e.constraints[r]&&(e.contexts||(e.contexts={}),e.contexts[r]=Object.assign(e.contexts[r]||{},t.context))}})},I.prototype.createValidationError=function(t,n,r,e){var a=t.constructor?t.constructor.name:void 0,i=this.getConstraintType(r,e),o={targetName:a,property:r.propertyName,object:t,value:n,constraints:r.constraints},s=r.message||"";return r.message||this.validatorOptions&&(!this.validatorOptions||this.validatorOptions.dismissDefaultMessages)||e&&e.instance.defaultMessage instanceof Function&&(s=e.instance.defaultMessage(o)),[i,v.replaceMessageSpecialTokens(s,o)]},I.prototype.getConstraintType=function(t,n){return n&&n.name?n.name:t.type},I);function I(t,n){this.validator=t,this.validatorOptions=n,this.awaitingPromises=[],this.ignoreAsyncValidations=!1,this.metadataStorage=s()}var h=(S.prototype.coreValidate=function(t,n,r){var e="string"==typeof t?n:t,a="string"==typeof t?t:void 0,i=new y(this,"string"==typeof t?r:n),o=[];return i.execute(e,a,o),Promise.all(i.awaitingPromises).then(function(){return i.stripEmptyErrors(o)})},S.prototype.validate=function(t,n,r){return this.coreValidate(t,n,r)},S.prototype.validateOrReject=function(r,e,a){return i.__awaiter(this,void 0,void 0,function(){var n;return i.__generator(this,function(t){switch(t.label){case 0:return[4,this.coreValidate(r,e,a)];case 1:return(n=t.sent()).length?[2,Promise.reject(n)]:[2]}})})},S.prototype.validateSync=function(t,n,r){var e="string"==typeof t?n:t,a="string"==typeof t?t:void 0,i=new y(this,"string"==typeof t?r:n);i.ignoreAsyncValidations=!0;var o=[];return i.execute(e,a,o),i.stripEmptyErrors(o)},S);function S(){}var M,b,A=(N.prototype.get=function(n){var t=this.instances.find(function(t){return t.type===n});return t||(t={type:n,object:new n},this.instances.push(t)),t.object},new N);function N(){this.instances=[]}function O(t){if(M)try{var n=M.get(t);if(n)return n;if(!b||!b.fallback)return n}catch(t){if(!b||!b.fallbackOnErrors)throw t}return A.get(t)}var E=(Object.defineProperty(_.prototype,"instance",{get:function(){return O(this.target)},enumerable:!0,configurable:!0}),_);function _(t,n,r){void 0===r&&(r=!1),this.target=t,this.name=n,this.async=r}function $(t){var n;if(t.validator instanceof Function){if(n=t.validator,1<O(u).getTargetValidatorConstraints(t.validator).length)throw"More than one implementation of ValidatorConstraintInterface found for validator on: "+t.target+":"+t.propertyName}else{var r=t.validator;e.prototype.validate=function(t,n){return r.validate(t,n)},e.prototype.defaultMessage=function(t){return r.defaultMessage?r.defaultMessage(t):""},n=e,s().addConstraintMetadata(new E(n,t.name,t.async))}function e(){}var a={type:t.name&&d.isValid(t.name)?t.name:d.CUSTOM_VALIDATION,target:t.target,propertyName:t.propertyName,validationOptions:t.options,constraintCls:n,constraints:t.constraints};s().addValidationMetadata(new o(a))}function T(r,e){return function(t){var n=e&&e.each?"each value in ":"";return r(n,t)}}function C(r,e){return function(t,n){$({name:r.name,target:t.constructor,propertyName:n,options:e,constraints:r.constraints,validator:r.validator})}}var D=d.IS_DEFINED;function L(t){return null!=t}var V="isLatLong";function R(t){return"string"==typeof t&&e.isLatLong(t)}var P="isLatitude";function w(t){return("number"==typeof t||"string"==typeof t)&&R(t+",0")}var x="isLongitude";function B(t){return("number"==typeof t||"string"==typeof t)&&R("0,"+t)}var U="equals";function H(t,n){return t===n}var j="notEquals";function F(t,n){return t!==n}var W="isEmpty";function q(t){return""===t||null==t}var Y="isNotEmpty";function k(t){return""!==t&&null!=t}function G(n,t){return!(t instanceof Array)||t.some(function(t){return t===n})}var J="isNotIn";function z(n,t){return!(t instanceof Array&&t.some(function(t){return t===n}))}var Q="isDivisibleBy";function X(t,n){return"number"==typeof t&&"number"==typeof n&&e.isDivisibleBy(String(t),n)}var Z="isPositive";function K(t){return"number"==typeof t&&0<t}var tt="isNegative";function nt(t){return"number"==typeof t&&t<0}function rt(t,n){return"number"==typeof t&&"number"==typeof n&&t<=n}function et(t,n){return"number"==typeof t&&"number"==typeof n&&n<=t}var at="minDate";function it(t,n){return t instanceof Date&&t.getTime()>=n.getTime()}var ot="maxDate";function st(t,n){return t instanceof Date&&t.getTime()<=n.getTime()}var ut="contains";function ct(t,n){return"string"==typeof t&&e.contains(t,n)}var ft="notContains";function lt(t,n){return"string"==typeof t&&!e.contains(t,n)}var dt="isAlpha";function pt(t,n){return"string"==typeof t&&e.isAlpha(t,n)}var vt="isAlphanumeric";function mt(t,n){return"string"==typeof t&&e.isAlphanumeric(t,n)}var yt="isDecimal";function gt(t,n){return"string"==typeof t&&e.isDecimal(t,n)}var It="isAscii";function ht(t){return"string"==typeof t&&e.isAscii(t)}var St="isBase64";function Mt(t){return"string"==typeof t&&e.isBase64(t)}var bt="isByteLength";function At(t,n,r){return"string"==typeof t&&e.isByteLength(t,{min:n,max:r})}var Nt="isCreditCard";function Ot(t){return"string"==typeof t&&e.isCreditCard(t)}var Et="isCurrency";function _t(t,n){return"string"==typeof t&&e.isCurrency(t,n)}var $t="isEmail";function Tt(t,n){return"string"==typeof t&&e.isEmail(t,n)}function Ct(t,n){return"string"==typeof t&&e.isFQDN(t,n)}var Dt="isFullWidth";function Lt(t){return"string"==typeof t&&e.isFullWidth(t)}var Vt="isHalfWidth";function Rt(t){return"string"==typeof t&&e.isHalfWidth(t)}var Pt="isVariableWidth";function wt(t){return"string"==typeof t&&e.isVariableWidth(t)}var xt="isHexColor";function Bt(t){return"string"==typeof t&&e.isHexColor(t)}var Ut="isHexadecimal";function Ht(t){return"string"==typeof t&&e.isHexadecimal(t)}function jt(t){return!!t&&("each"in t||"message"in t||"groups"in t||"always"in t||"context"in t)}var Ft="isMacAddress";function Wt(t,n){return"string"==typeof t&&e.isMACAddress(t,n)}function qt(t,n){var r=n?""+n:void 0;return"string"==typeof t&&e.isIP(t,r)}function Yt(t){return"string"==typeof t&&e.isPort(t)}function kt(t,n){var r=n?""+n:void 0;return"string"==typeof t&&e.isISBN(t,r)}function Gt(t){return"string"==typeof t&&e.isISIN(t)}var Jt="isIso8601";function zt(t,n){return"string"==typeof t&&e.isISO8601(t,n)}function Qt(t){return"string"==typeof t&&e.isJSON(t)}function Xt(t){return"string"==typeof t&&e.isJWT(t)}var Zt="isLowercase";function Kt(t){return"string"==typeof t&&e.isLowercase(t)}var tn="isMobilePhone";function nn(t,n,r){return"string"==typeof t&&e.isMobilePhone(t,n,r)}var rn="isISO31661Alpha2";function en(t){return"string"==typeof t&&e.isISO31661Alpha2(t)}var an="isISO31661Alpha3";function on(t){return"string"==typeof t&&e.isISO31661Alpha3(t)}var sn="isMongoId";function un(t){return"string"==typeof t&&e.isMongoId(t)}var cn="isMultibyte";function fn(t){return"string"==typeof t&&e.isMultibyte(t)}var ln="isSurrogatePair";function dn(t){return"string"==typeof t&&e.isSurrogatePair(t)}function pn(t,n){return"string"==typeof t&&e.isURL(t,n)}function vn(t,n){return"string"==typeof t&&e.isUUID(t,n)}var mn="IsFirebasePushId";function yn(t){return"string"==typeof t&&20===t.length&&/^[a-zA-Z0-9_-]*$/.test(t)}var gn="isUppercase";function In(t){return"string"==typeof t&&e.isUppercase(t)}function hn(t,n,r){return"string"==typeof t&&e.isLength(t,{min:n,max:r})}var Sn="maxLength";function Mn(t,n){return"string"==typeof t&&e.isLength(t,{min:0,max:n})}var bn="minLength";function An(t,n){return"string"==typeof t&&e.isLength(t,{min:n})}var Nn="matches";function On(t,n,r){return"string"==typeof t&&e.matches(t,n,r)}var En="isPhoneNumber";function _n(t,n){var r=a.PhoneNumberUtil.getInstance();try{var e=r.parseAndKeepRawInput(t,n);return r.isValidNumber(e)}catch(t){return!1}}var $n="isMilitaryTime";function Tn(t){return"string"==typeof t&&e.matches(t,/^([01]\d|2[0-3]):?([0-5]\d)$/)}function Cn(t,n){return"string"==typeof t&&e.isHash(t,n)}function Dn(t,n){return"string"==typeof t&&e.isISSN(t,n)}var Ln="isDateString";function Vn(t){return"string"==typeof t&&/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:Z|[\+\-][0-2]\d(?:\:[0-5]\d)?)?$/g.test(t)}var Rn="isBooleanString";function Pn(t){return"string"==typeof t&&e.isBoolean(t)}var wn="isNumberString";function xn(t,n){return"string"==typeof t&&e.isNumeric(t,n)}var Bn="isBase32";function Un(t){return"string"==typeof t&&e.isBase32(t)}function Hn(t){return"string"==typeof t&&e.isBIC(t)}var jn="isBtcAddress";function Fn(t){return"string"==typeof t&&e.isBtcAddress(t)}var Wn="isDataURI";function qn(t){return"string"==typeof t&&e.isDataURI(t)}function Yn(t){return"string"==typeof t&&e.isEAN(t)}var kn="isEthereumAddress";function Gn(t){return"string"==typeof t&&e.isEthereumAddress(t)}function Jn(t){return"string"==typeof t&&e.isHSL(t)}function zn(t){return"string"==typeof t&&e.isIBAN(t)}var Qn="isIdentityCard";function Xn(t,n){return"string"==typeof t&&e.isIdentityCard(t,n)}function Zn(t){return"string"==typeof t&&e.isISRC(t)}var Kn="isLocale";function tr(t){return"string"==typeof t&&e.isLocale(t)}var nr="isMagnetURI";function rr(t){return"string"==typeof t&&e.isMagnetURI(t)}var er="isMimeType";function ar(t){return"string"==typeof t&&e.isMimeType(t)}var ir="isOctal";function or(t){return"string"==typeof t&&e.isOctal(t)}var sr="isPassportNumber";function ur(t,n){return"string"==typeof t&&e.isPassportNumber(t,n)}var cr="isPostalCode";function fr(t,n){return"string"==typeof t&&e.isPostalCode(t,n)}var lr="isRFC3339";function dr(t){return"string"==typeof t&&e.isRFC3339(t)}var pr="isRgbColor";function vr(t,n){return"string"==typeof t&&e.isRgbColor(t,n)}var mr="isSemVer";function yr(t){return"string"==typeof t&&e.isSemVer(t)}var gr="isBoolean";function Ir(t){return t instanceof Boolean||"boolean"==typeof t}function hr(t){return t instanceof Date&&!isNaN(t.getTime())}var Sr="isNumber";function Mr(t,n){if(void 0===n&&(n={}),"number"!=typeof t)return!1;if(t===1/0||t===-1/0)return n.allowInfinity;if(Number.isNaN(t))return n.allowNaN;if(void 0!==n.maxDecimalPlaces){var r=0;if(t%1!=0&&(r=t.toString().split(".")[1].length),r>n.maxDecimalPlaces)return!1}return Number.isFinite(t)}function br(t,n){return 0<=Object.keys(n).map(function(t){return n[t]}).indexOf(t)}function Ar(t){return"number"==typeof t&&Number.isInteger(t)}var Nr="isString";function Or(t){return t instanceof String||"string"==typeof t}var Er="isArray";function _r(t){return t instanceof Array}var $r="isObject";function Tr(t){return null!=t&&("object"==typeof t||"function"==typeof t)&&!Array.isArray(t)}var Cr="arrayContains";function Dr(n,t){return n instanceof Array&&t.every(function(t){return-1!==n.indexOf(t)})}var Lr="arrayNotContains";function Vr(n,t){return n instanceof Array&&t.every(function(t){return-1===n.indexOf(t)})}var Rr="arrayNotEmpty";function Pr(t){return t instanceof Array&&0<t.length}var wr="arrayMinSize";function xr(t,n){return t instanceof Array&&t.length>=n}var Br="arrayMaxSize";function Ur(t,n){return t instanceof Array&&t.length<=n}var Hr="arrayUnique";function jr(t){if(!(t instanceof Array))return!1;var n=t.filter(function(t,n,r){return r.indexOf(t)===n});return t.length===n.length}var Fr="isNotEmptyObject";function Wr(t){if(!Tr(t))return!1;for(var n in t)if(t.hasOwnProperty(n))return!0;return!1}var qr="isInstance";function Yr(t,n){return n&&"function"==typeof n&&t instanceof n}t.ARRAY_CONTAINS=Cr,t.ARRAY_MAX_SIZE=Br,t.ARRAY_MIN_SIZE=wr,t.ARRAY_NOT_CONTAINS=Lr,t.ARRAY_NOT_EMPTY=Rr,t.ARRAY_UNIQUE=Hr,t.Allow=function(e){return function(t,n){var r={type:d.WHITELIST,target:t.constructor,propertyName:n,validationOptions:e};s().addValidationMetadata(new o(r))}},t.ArrayContains=function(t,n){return C({name:Cr,constraints:[t],validator:{validate:function(t,n){return Dr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain $constraint1 values"},n)}},n)},t.ArrayMaxSize=function(t,n){return C({name:Br,constraints:[t],validator:{validate:function(t,n){return Ur(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain not more than $constraint1 elements"},n)}},n)},t.ArrayMinSize=function(t,n){return C({name:wr,constraints:[t],validator:{validate:function(t,n){return xr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain at least $constraint1 elements"},n)}},n)},t.ArrayNotContains=function(t,n){return C({name:Lr,constraints:[t],validator:{validate:function(t,n){return Vr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property should not contain $constraint1 values"},n)}},n)},t.ArrayNotEmpty=function(t){return C({name:Rr,validator:{validate:function(t,n){return Pr(t)},defaultMessage:T(function(t){return t+"$property should not be empty"},t)}},t)},t.ArrayUnique=function(t){return C({name:Hr,validator:{validate:function(t,n){return jr(t)},defaultMessage:T(function(t){return t+"All $property's elements must be unique"},t)}},t)},t.CONTAINS=ut,t.Contains=function(t,n){return C({name:ut,constraints:[t],validator:{validate:function(t,n){return ct(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain a $constraint1 string"},n)}},n)},t.EQUALS=U,t.Equals=function(t,n){return C({name:U,constraints:[t],validator:{validate:function(t,n){return H(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be equal to $constraint1"},n)}},n)},t.IS_ALPHA=dt,t.IS_ALPHANUMERIC=vt,t.IS_ARRAY=Er,t.IS_ASCII=It,t.IS_BASE32=Bn,t.IS_BASE64=St,t.IS_BIC="isBIC",t.IS_BOOLEAN=gr,t.IS_BOOLEAN_STRING=Rn,t.IS_BTC_ADDRESS=jn,t.IS_BYTE_LENGTH=bt,t.IS_CREDIT_CARD=Nt,t.IS_CURRENCY=Et,t.IS_DATA_URI=Wn,t.IS_DATE="isDate",t.IS_DATE_STRING=Ln,t.IS_DECIMAL=yt,t.IS_DEFINED=D,t.IS_DIVISIBLE_BY=Q,t.IS_EAN="isEAN",t.IS_EMAIL=$t,t.IS_EMPTY=W,t.IS_ENUM="isEnum",t.IS_ETHEREUM_ADDRESS=kn,t.IS_FIREBASE_PUSH_ID=mn,t.IS_FQDN="isFqdn",t.IS_FULL_WIDTH=Dt,t.IS_HALF_WIDTH=Vt,t.IS_HASH="isHash",t.IS_HEXADECIMAL=Ut,t.IS_HEX_COLOR=xt,t.IS_HSL="isHSL",t.IS_IBAN="isIBAN",t.IS_IDENTITY_CARD=Qn,t.IS_IN="isIn",t.IS_INSTANCE=qr,t.IS_INT="isInt",t.IS_IP="isIp",t.IS_ISBN="isIsbn",t.IS_ISIN="isIsin",t.IS_ISO31661_ALPHA_2=rn,t.IS_ISO31661_ALPHA_3=an,t.IS_ISO8601=Jt,t.IS_ISRC="isISRC",t.IS_ISSN="isISSN",t.IS_JSON="isJson",t.IS_JWT="isJwt",t.IS_LATITUDE=P,t.IS_LATLONG=V,t.IS_LOCALE=Kn,t.IS_LONGITUDE=x,t.IS_LOWERCASE=Zt,t.IS_MAC_ADDRESS=Ft,t.IS_MAGNET_URI=nr,t.IS_MILITARY_TIME=$n,t.IS_MIME_TYPE=er,t.IS_MOBILE_PHONE=tn,t.IS_MONGO_ID=sn,t.IS_MULTIBYTE=cn,t.IS_NEGATIVE=tt,t.IS_NOT_EMPTY=Y,t.IS_NOT_EMPTY_OBJECT=Fr,t.IS_NOT_IN=J,t.IS_NUMBER=Sr,t.IS_NUMBER_STRING=wn,t.IS_OBJECT=$r,t.IS_OCTAL=ir,t.IS_PASSPORT_NUMBER=sr,t.IS_PHONE_NUMBER=En,t.IS_PORT="isPort",t.IS_POSITIVE=Z,t.IS_POSTAL_CODE=cr,t.IS_RFC_3339=lr,t.IS_RGB_COLOR=pr,t.IS_SEM_VER=mr,t.IS_STRING=Nr,t.IS_SURROGATE_PAIR=ln,t.IS_UPPERCASE=gn,t.IS_URL="isUrl",t.IS_UUID="isUuid",t.IS_VARIABLE_WIDTH=Pt,t.IsAlpha=function(t,n){return C({name:dt,constraints:[t],validator:{validate:function(t,n){return pt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain only letters (a-zA-Z)"},n)}},n)},t.IsAlphanumeric=function(t,n){return C({name:vt,constraints:[t],validator:{validate:function(t,n){return mt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain only letters and numbers"},n)}},n)},t.IsArray=function(t){return C({name:Er,validator:{validate:function(t,n){return _r(t)},defaultMessage:T(function(t){return t+"$property must be an array"},t)}},t)},t.IsAscii=function(t){return C({name:It,validator:{validate:function(t,n){return ht(t)},defaultMessage:T(function(t){return t+"$property must contain only ASCII characters"},t)}},t)},t.IsBIC=function(t){return C({name:"isBIC",validator:{validate:function(t,n){return Hn(t)},defaultMessage:T(function(t){return t+"$property must be a BIC or SWIFT code"},t)}},t)},t.IsBase32=function(t){return C({name:Bn,validator:{validate:function(t,n){return Un(t)},defaultMessage:T(function(t){return t+"$property must be base32 encoded"},t)}},t)},t.IsBase64=function(t){return C({name:St,validator:{validate:function(t,n){return Mt(t)},defaultMessage:T(function(t){return t+"$property must be base64 encoded"},t)}},t)},t.IsBoolean=function(t){return C({name:gr,validator:{validate:function(t,n){return Ir(t)},defaultMessage:T(function(t){return t+"$property must be a boolean value"},t)}},t)},t.IsBooleanString=function(t){return C({name:Rn,validator:{validate:function(t,n){return Pn(t)},defaultMessage:T(function(t){return t+"$property must be a boolean string"},t)}},t)},t.IsBtcAddress=function(t){return C({name:jn,validator:{validate:function(t,n){return Fn(t)},defaultMessage:T(function(t){return t+"$property must be a BTC address"},t)}},t)},t.IsByteLength=function(t,n,r){return C({name:bt,constraints:[t,n],validator:{validate:function(t,n){return At(t,n.constraints[0],n.constraints[1])},defaultMessage:T(function(t){return t+"$property's byte length must fall into ($constraint1, $constraint2) range"},r)}},r)},t.IsCreditCard=function(t){return C({name:Nt,validator:{validate:function(t,n){return Ot(t)},defaultMessage:T(function(t){return t+"$property must be a credit card"},t)}},t)},t.IsCurrency=function(t,n){return C({name:Et,constraints:[t],validator:{validate:function(t,n){return _t(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a currency"},n)}},n)},t.IsDataURI=function(t){return C({name:Wn,validator:{validate:function(t,n){return qn(t)},defaultMessage:T(function(t){return t+"$property must be a data uri format"},t)}},t)},t.IsDate=function(t){return C({name:"isDate",validator:{validate:function(t,n){return hr(t)},defaultMessage:T(function(t){return t+"$property must be a Date instance"},t)}},t)},t.IsDateString=function(t){return C({name:Ln,validator:{validate:function(t,n){return Vn(t)},defaultMessage:T(function(t){return t+"$property must be a ISOString"},t)}},t)},t.IsDecimal=function(t,n){return C({name:yt,constraints:[t],validator:{validate:function(t,n){return gt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property is not a valid decimal number."},n)}},n)},t.IsDefined=function(t){return C({name:D,validator:{validate:function(t){return L(t)},defaultMessage:T(function(t){return t+"$property should not be null or undefined"},t)}},t)},t.IsDivisibleBy=function(t,n){return C({name:Q,constraints:[t],validator:{validate:function(t,n){return X(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be divisible by $constraint1"},n)}},n)},t.IsEAN=function(t){return C({name:"isEAN",validator:{validate:function(t,n){return Yn(t)},defaultMessage:T(function(t){return t+"$property must be an EAN (European Article Number)"},t)}},t)},t.IsEmail=function(t,n){return C({name:$t,constraints:[t],validator:{validate:function(t,n){return Tt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be an email"},n)}},n)},t.IsEmpty=function(t){return C({name:W,validator:{validate:function(t,n){return q(t)},defaultMessage:T(function(t){return t+"$property must be empty"},t)}},t)},t.IsEnum=function(t,n){return C({name:"isEnum",constraints:[t],validator:{validate:function(t,n){return br(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a valid enum value"},n)}},n)},t.IsEthereumAddress=function(t){return C({name:kn,validator:{validate:function(t,n){return Gn(t)},defaultMessage:T(function(t){return t+"$property must be an Ethereum address"},t)}},t)},t.IsFQDN=function(t,n){return C({name:"isFqdn",constraints:[t],validator:{validate:function(t,n){return Ct(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a valid domain name"},n)}},n)},t.IsFirebasePushId=function(t){return C({name:mn,validator:{validate:function(t,n){return yn(t)},defaultMessage:T(function(t){return t+"$property must be a Firebase Push Id"},t)}},t)},t.IsFullWidth=function(t){return C({name:Dt,validator:{validate:function(t,n){return Lt(t)},defaultMessage:T(function(t){return t+"$property must contain a full-width characters"},t)}},t)},t.IsHSL=function(t){return C({name:"isHSL",validator:{validate:function(t,n){return Jn(t)},defaultMessage:T(function(t){return t+"$property must be a HSL color"},t)}},t)},t.IsHalfWidth=function(t){return C({name:Vt,validator:{validate:function(t,n){return Rt(t)},defaultMessage:T(function(t){return t+"$property must contain a half-width characters"},t)}},t)},t.IsHash=function(t,n){return C({name:"isHash",constraints:[t],validator:{validate:function(t,n){return Cn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a hash of type $constraint1"},n)}},n)},t.IsHexColor=function(t){return C({name:xt,validator:{validate:function(t,n){return Bt(t)},defaultMessage:T(function(t){return t+"$property must be a hexadecimal color"},t)}},t)},t.IsHexadecimal=function(t){return C({name:Ut,validator:{validate:function(t,n){return Ht(t)},defaultMessage:T(function(t){return t+"$property must be a hexadecimal number"},t)}},t)},t.IsIBAN=function(t){return C({name:"isIBAN",validator:{validate:function(t,n){return zn(t)},defaultMessage:T(function(t){return t+"$property must be an IBAN"},t)}},t)},t.IsIP=function(t,n){return C({name:"isIp",constraints:[t],validator:{validate:function(t,n){return qt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be an ip address"},n)}},n)},t.IsISBN=function(t,n){return C({name:"isIsbn",constraints:[t],validator:{validate:function(t,n){return kt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be an ISBN"},n)}},n)},t.IsISIN=function(t){return C({name:"isIsin",validator:{validate:function(t,n){return Gt(t)},defaultMessage:T(function(t){return t+"$property must be an ISIN (stock/security identifier)"},t)}},t)},t.IsISO31661Alpha2=function(t){return C({name:rn,validator:{validate:function(t,n){return en(t)},defaultMessage:T(function(t){return t+"$property must be a valid ISO31661 Alpha2 code"},t)}},t)},t.IsISO31661Alpha3=function(t){return C({name:an,validator:{validate:function(t,n){return on(t)},defaultMessage:T(function(t){return t+"$property must be a valid ISO31661 Alpha3 code"},t)}},t)},t.IsISO8601=function(t,n){return C({name:Jt,constraints:[t],validator:{validate:function(t,n){return zt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a valid ISO 8601 date string"},n)}},n)},t.IsISRC=function(t){return C({name:"isISRC",validator:{validate:function(t,n){return Zn(t)},defaultMessage:T(function(t){return t+"$property must be an ISRC"},t)}},t)},t.IsISSN=function(t,n){return C({name:"isISSN",constraints:[t],validator:{validate:function(t,n){return Dn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a ISSN"},n)}},n)},t.IsIdentityCard=function(t,n){return C({name:Qn,constraints:[t],validator:{validate:function(t,n){return Xn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a identity card number"},n)}},n)},t.IsIn=function(t,n){return C({name:"isIn",constraints:[t],validator:{validate:function(t,n){return G(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be one of the following values: $constraint1"},n)}},n)},t.IsInstance=function(t,n){return C({name:qr,constraints:[t],validator:{validate:function(t,n){return Yr(t,n.constraints[0])},defaultMessage:T(function(t,n){return n.constraints[0]?t+("$property must be an instance of "+n.constraints[0].name):t+qr+" decorator expects and object as value, but got falsy value."},n)}},n)},t.IsInt=function(t){return C({name:"isInt",validator:{validate:function(t,n){return Ar(t)},defaultMessage:T(function(t){return t+"$property must be an integer number"},t)}},t)},t.IsJSON=function(t){return C({name:"isJson",validator:{validate:function(t,n){return Qt(t)},defaultMessage:T(function(t){return t+"$property must be a json string"},t)}},t)},t.IsJWT=function(t){return C({name:"isJwt",validator:{validate:function(t,n){return Xt(t)},defaultMessage:T(function(t){return t+"$property must be a jwt string"},t)}},t)},t.IsLatLong=function(t){return C({name:V,validator:{validate:function(t,n){return R(t)},defaultMessage:T(function(t){return t+"$property must be a latitude,longitude string"},t)}},t)},t.IsLatitude=function(t){return C({name:P,validator:{validate:function(t,n){return w(t)},defaultMessage:T(function(t){return t+"$property must be a latitude string or number"},t)}},t)},t.IsLocale=function(t){return C({name:Kn,validator:{validate:function(t,n){return tr(t)},defaultMessage:T(function(t){return t+"$property must be locale"},t)}},t)},t.IsLongitude=function(t){return C({name:x,validator:{validate:function(t,n){return B(t)},defaultMessage:T(function(t){return t+"$property must be a longitude string or number"},t)}},t)},t.IsLowercase=function(t){return C({name:Zt,validator:{validate:function(t,n){return Kt(t)},defaultMessage:T(function(t){return t+"$property must be a lowercase string"},t)}},t)},t.IsMACAddress=function(t,n){var r=jt(t)?void 0:t,e=jt(t)?t:n;return C({name:Ft,constraints:[r],validator:{validate:function(t,n){return Wt(t,r)},defaultMessage:T(function(t){return t+"$property must be a MAC Address"},e)}},e)},t.IsMagnetURI=function(t){return C({name:nr,validator:{validate:function(t,n){return rr(t)},defaultMessage:T(function(t){return t+"$property must be magnet uri format"},t)}},t)},t.IsMilitaryTime=function(t){return C({name:$n,validator:{validate:function(t,n){return Tn(t)},defaultMessage:T(function(t){return t+"$property must be a valid representation of military time in the format HH:MM"},t)}},t)},t.IsMimeType=function(t){return C({name:er,validator:{validate:function(t,n){return ar(t)},defaultMessage:T(function(t){return t+"$property must be MIME type format"},t)}},t)},t.IsMobilePhone=function(t,n,r){return C({name:tn,constraints:[t,n],validator:{validate:function(t,n){return nn(t,n.constraints[0],n.constraints[1])},defaultMessage:T(function(t){return t+"$property must be a phone number"},r)}},r)},t.IsMongoId=function(t){return C({name:sn,validator:{validate:function(t,n){return un(t)},defaultMessage:T(function(t){return t+"$property must be a mongodb id"},t)}},t)},t.IsMultibyte=function(t){return C({name:cn,validator:{validate:function(t,n){return fn(t)},defaultMessage:T(function(t){return t+"$property must contain one or more multibyte chars"},t)}},t)},t.IsNegative=function(t){return C({name:tt,validator:{validate:function(t,n){return nt(t)},defaultMessage:T(function(t){return t+"$property must be a negative number"},t)}},t)},t.IsNotEmpty=function(t){return C({name:Y,validator:{validate:function(t,n){return k(t)},defaultMessage:T(function(t){return t+"$property should not be empty"},t)}},t)},t.IsNotEmptyObject=function(t){return C({name:Fr,validator:{validate:function(t,n){return Wr(t)},defaultMessage:T(function(t){return t+"$property must be a non-empty object"},t)}},t)},t.IsNotIn=function(t,n){return C({name:J,constraints:[t],validator:{validate:function(t,n){return z(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property should not be one of the following values: $constraint1"},n)}},n)},t.IsNumber=function(t,n){return void 0===t&&(t={}),C({name:Sr,constraints:[t],validator:{validate:function(t,n){return Mr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a number conforming to the specified constraints"},n)}},n)},t.IsNumberString=function(t,n){return C({name:wn,constraints:[t],validator:{validate:function(t,n){return xn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a number string"},n)}},n)},t.IsObject=function(t){return C({name:$r,validator:{validate:function(t,n){return Tr(t)},defaultMessage:T(function(t){return t+"$property must be an object"},t)}},t)},t.IsOctal=function(t){return C({name:ir,validator:{validate:function(t,n){return or(t)},defaultMessage:T(function(t){return t+"$property must be valid octal number"},t)}},t)},t.IsOptional=function(e){return function(t,r){var n={type:d.CONDITIONAL_VALIDATION,target:t.constructor,propertyName:r,constraints:[function(t,n){return null!==t[r]&&void 0!==t[r]}],validationOptions:e};s().addValidationMetadata(new o(n))}},t.IsPassportNumber=function(t,n){return C({name:sr,constraints:[t],validator:{validate:function(t,n){return ur(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be valid passport number"},n)}},n)},t.IsPhoneNumber=function(t,n){return C({name:En,constraints:[t],validator:{validate:function(t,n){return _n(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a valid phone number"},n)}},n)},t.IsPort=function(t){return C({name:"isPort",validator:{validate:function(t,n){return Yt(t)},defaultMessage:T(function(t){return t+"$property must be a port"},t)}},t)},t.IsPositive=function(t){return C({name:Z,validator:{validate:function(t,n){return K(t)},defaultMessage:T(function(t){return t+"$property must be a positive number"},t)}},t)},t.IsPostalCode=function(t,n){return C({name:cr,constraints:[t],validator:{validate:function(t,n){return fr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a postal code"},n)}},n)},t.IsRFC3339=function(t){return C({name:lr,validator:{validate:function(t,n){return dr(t)},defaultMessage:T(function(t){return t+"$property must be RFC 3339 date"},t)}},t)},t.IsRgbColor=function(t,n){return C({name:pr,constraints:[t],validator:{validate:function(t,n){return vr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be RGB color"},n)}},n)},t.IsSemVer=function(t){return C({name:mr,validator:{validate:function(t,n){return yr(t)},defaultMessage:T(function(t){return t+"$property must be a Semantic Versioning Specification"},t)}},t)},t.IsString=function(t){return C({name:Nr,validator:{validate:function(t,n){return Or(t)},defaultMessage:T(function(t){return t+"$property must be a string"},t)}},t)},t.IsSurrogatePair=function(t){return C({name:ln,validator:{validate:function(t,n){return dn(t)},defaultMessage:T(function(t){return t+"$property must contain any surrogate pairs chars"},t)}},t)},t.IsUUID=function(t,n){return C({name:"isUuid",constraints:[t],validator:{validate:function(t,n){return vn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be an UUID"},n)}},n)},t.IsUppercase=function(t){return C({name:gn,validator:{validate:function(t,n){return In(t)},defaultMessage:T(function(t){return t+"$property must be uppercase"},t)}},t)},t.IsUrl=function(t,n){return C({name:"isUrl",constraints:[t],validator:{validate:function(t,n){return pn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be an URL address"},n)}},n)},t.IsVariableWidth=function(t){return C({name:Pt,validator:{validate:function(t,n){return wt(t)},defaultMessage:T(function(t){return t+"$property must contain a full-width and half-width characters"},t)}},t)},t.LENGTH="length",t.Length=function(t,n,r){return C({name:"length",constraints:[t,n],validator:{validate:function(t,n){return hn(t,n.constraints[0],n.constraints[1])},defaultMessage:T(function(t,n){var r=null!==n.constraints[0]&&void 0!==n.constraints[0],e=null!==n.constraints[1]&&void 0!==n.constraints[1];return r&&(!n.value||n.value.length<n.constraints[0])?t+"$property must be longer than or equal to $constraint1 characters":e&&n.value.length>n.constraints[1]?t+"$property must be shorter than or equal to $constraint2 characters":t+"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters"},r)}},r)},t.MATCHES=Nn,t.MAX="max",t.MAX_DATE=ot,t.MAX_LENGTH=Sn,t.MIN="min",t.MIN_DATE=at,t.MIN_LENGTH=bn,t.Matches=function(t,n,r){var e;return n&&n instanceof Object&&!r?r=n:e=n,C({name:Nn,constraints:[t,e],validator:{validate:function(t,n){return On(t,n.constraints[0],n.constraints[0])},defaultMessage:T(function(t,n){return t+"$property must match $constraint1 regular expression"},r)}},r)},t.Max=function(t,n){return C({name:"max",constraints:[t],validator:{validate:function(t,n){return rt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must not be greater than $constraint1"},n)}},n)},t.MaxDate=function(t,n){return C({name:ot,constraints:[t],validator:{validate:function(t,n){return st(t,n.constraints[0])},defaultMessage:T(function(t){return"maximal allowed date for "+t+"$property is $constraint1"},n)}},n)},t.MaxLength=function(t,n){return C({name:Sn,constraints:[t],validator:{validate:function(t,n){return Mn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be shorter than or equal to $constraint1 characters"},n)}},n)},t.MetadataStorage=u,t.Min=function(t,n){return C({name:"min",constraints:[t],validator:{validate:function(t,n){return et(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must not be less than $constraint1"},n)}},n)},t.MinDate=function(t,n){return C({name:at,constraints:[t],validator:{validate:function(t,n){return it(t,n.constraints[0])},defaultMessage:T(function(t){return"minimal allowed date for "+t+"$property is $constraint1"},n)}},n)},t.MinLength=function(t,n){return C({name:bn,constraints:[t],validator:{validate:function(t,n){return An(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be longer than or equal to $constraint1 characters"},n)}},n)},t.NOT_CONTAINS=ft,t.NOT_EQUALS=j,t.NotContains=function(t,n){return C({name:ft,constraints:[t],validator:{validate:function(t,n){return lt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property should not contain a $constraint1 string"},n)}},n)},t.NotEquals=function(t,n){return C({name:j,constraints:[t],validator:{validate:function(t,n){return F(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property should not be equal to $constraint1"},n)}},n)},t.Validate=function(e,a,i){return function(t,n){var r={type:d.CUSTOM_VALIDATION,target:t.constructor,propertyName:n,constraintCls:e,constraints:a instanceof Array?a:void 0,validationOptions:a instanceof Array?i:a};s().addValidationMetadata(new o(r))}},t.ValidateBy=C,t.ValidateIf=function(e,a){return function(t,n){var r={type:d.CONDITIONAL_VALIDATION,target:t.constructor,propertyName:n,constraints:[e],validationOptions:a};s().addValidationMetadata(new o(r))}},t.ValidateNested=function(t){var e=i.__assign({},t),n=e.each?"each value in ":"";return e.message=e.message||n+"nested property $property must be either object or array",function(t,n){var r={type:d.NESTED_VALIDATION,target:t.constructor,propertyName:n,validationOptions:e};s().addValidationMetadata(new o(r))}},t.ValidatePromise=function(e){return function(t,n){var r={type:d.PROMISE_VALIDATION,target:t.constructor,propertyName:n,validationOptions:e};s().addValidationMetadata(new o(r))}},t.ValidationError=l,t.ValidationTypes=d,t.Validator=h,t.ValidatorConstraint=function(a){return function(t){var n=!(!a||!a.async),r=a&&a.name?a.name:"";r=r||((r=t.name)||r.replace(/\.?([A-Z]+)/g,function(t,n){return"_"+n.toLowerCase()}).replace(/^_/,""));var e=new E(t,r,n);s().addConstraintMetadata(e)}},t.arrayContains=Dr,t.arrayMaxSize=Ur,t.arrayMinSize=xr,t.arrayNotContains=Vr,t.arrayNotEmpty=Pr,t.arrayUnique=jr,t.buildMessage=T,t.contains=ct,t.equals=H,t.getFromContainer=O,t.getMetadataStorage=s,t.isAlpha=pt,t.isAlphanumeric=mt,t.isArray=_r,t.isAscii=ht,t.isBIC=Hn,t.isBase32=Un,t.isBase64=Mt,t.isBoolean=Ir,t.isBooleanString=Pn,t.isBtcAddress=Fn,t.isByteLength=At,t.isCreditCard=Ot,t.isCurrency=_t,t.isDataURI=qn,t.isDate=hr,t.isDateString=Vn,t.isDecimal=gt,t.isDefined=L,t.isDivisibleBy=X,t.isEAN=Yn,t.isEmail=Tt,t.isEmpty=q,t.isEnum=br,t.isEthereumAddress=Gn,t.isFQDN=Ct,t.isFirebasePushId=yn,t.isFullWidth=Lt,t.isHSL=Jn,t.isHalfWidth=Rt,t.isHash=Cn,t.isHexColor=Bt,t.isHexadecimal=Ht,t.isIBAN=zn,t.isIP=qt,t.isISBN=kt,t.isISIN=Gt,t.isISO31661Alpha2=en,t.isISO31661Alpha3=on,t.isISO8601=zt,t.isISRC=Zn,t.isISSN=Dn,t.isIdentityCard=Xn,t.isIn=G,t.isInstance=Yr,t.isInt=Ar,t.isJSON=Qt,t.isJWT=Xt,t.isLatLong=R,t.isLatitude=w,t.isLocale=tr,t.isLongitude=B,t.isLowercase=Kt,t.isMACAddress=Wt,t.isMagnetURI=rr,t.isMilitaryTime=Tn,t.isMimeType=ar,t.isMobilePhone=nn,t.isMongoId=un,t.isMultibyte=fn,t.isNegative=nt,t.isNotEmpty=k,t.isNotEmptyObject=Wr,t.isNotIn=z,t.isNumber=Mr,t.isNumberString=xn,t.isObject=Tr,t.isOctal=or,t.isPassportNumber=ur,t.isPhoneNumber=_n,t.isPort=Yt,t.isPositive=K,t.isPostalCode=fr,t.isRFC3339=dr,t.isRgbColor=vr,t.isSemVer=yr,t.isString=Or,t.isSurrogatePair=dn,t.isURL=pn,t.isUUID=vn,t.isUppercase=In,t.isValidationOptions=jt,t.isVariableWidth=wt,t.length=hn,t.matches=On,t.max=rt,t.maxDate=st,t.maxLength=Mn,t.min=et,t.minDate=it,t.minLength=An,t.notContains=lt,t.notEquals=F,t.registerDecorator=$,t.registerSchema=function(t){s().addValidationSchema(t)},t.useContainer=function(t,n){M=t,b=n},t.validate=function(t,n,r){return"string"==typeof t?O(h).validate(t,n,r):O(h).validate(t,n)},t.validateOrReject=function(t,n,r){return"string"==typeof t?O(h).validateOrReject(t,n,r):O(h).validateOrReject(t,n)},t.validateSync=function(t,n,r){return"string"==typeof t?O(h).validateSync(t,n,r):O(h).validateSync(t,n)},Object.defineProperty(t,"__esModule",{value:!0})});
+!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("tslib"),require("validator"),require("google-libphonenumber")):"function"==typeof define&&define.amd?define(["exports","tslib","validator","google-libphonenumber"],n):n((t=t||self).ClassValidator={},t.tslib_1,t.validator,t.googleLibphonenumber)}(this,function(t,i,e,a){"use strict";e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e;var o=function(t){this.groups=[],this.always=!1,this.each=!1,this.context=void 0,this.type=t.type,this.target=t.target,this.propertyName=t.propertyName,this.constraints=t.constraints,this.constraintCls=t.constraintCls,this.validationTypeOptions=t.validationTypeOptions,t.validationOptions&&(this.message=t.validationOptions.message,this.groups=t.validationOptions.groups,this.always=t.validationOptions.always,this.each=t.validationOptions.each,this.context=t.validationOptions.context)},r=(n.prototype.transform=function(a){var i=[];return Object.keys(a.properties).forEach(function(e){a.properties[e].forEach(function(t){var n={message:t.message,groups:t.groups,always:t.always,each:t.each},r={type:t.type,target:a.name,propertyName:e,constraints:t.constraints,validationTypeOptions:t.options,validationOptions:n};i.push(new o(r))})}),i},n);function n(){}function s(){return"undefined"!=typeof window&&(window.global=window),global.classValidatorMetadataStorage||(global.classValidatorMetadataStorage=new u),global.classValidatorMetadataStorage}var u=(Object.defineProperty(c.prototype,"hasValidationMetaData",{get:function(){return!!this.validationMetadatas.length},enumerable:!0,configurable:!0}),c.prototype.addValidationSchema=function(t){var n=this;(new r).transform(t).forEach(function(t){return n.addValidationMetadata(t)})},c.prototype.addValidationMetadata=function(t){this.validationMetadatas.push(t)},c.prototype.addConstraintMetadata=function(t){this.constraintMetadatas.push(t)},c.prototype.groupByPropertyName=function(t){var n={};return t.forEach(function(t){n[t.propertyName]||(n[t.propertyName]=[]),n[t.propertyName].push(t)}),n},c.prototype.getTargetValidationMetadatas=function(n,r,e){var t=this.validationMetadatas.filter(function(t){return(t.target===n||t.target===r)&&(!!t.always||!(e&&0<e.length)||t.groups&&!!t.groups.find(function(t){return-1!==e.indexOf(t)}))}),a=this.validationMetadatas.filter(function(t){return"string"!=typeof t.target&&t.target!==n&&(!(t.target instanceof Function)||n.prototype instanceof t.target)&&(!!t.always||!(e&&0<e.length)||t.groups&&!!t.groups.find(function(t){return-1!==e.indexOf(t)}))}).filter(function(n){return!t.find(function(t){return t.propertyName===n.propertyName&&t.type===n.type})});return t.concat(a)},c.prototype.getTargetValidatorConstraints=function(n){return this.constraintMetadatas.filter(function(t){return t.target===n})},c);function c(){this.validationMetadatas=[],this.constraintMetadatas=[]}var f=(l.prototype.toString=function(n,t,r){var e=this;function a(t){return" - property "+i+r+t+o+" has failed the following constraints: "+i+Object.keys(e.constraints).join(", ")+o+" \n"}void 0===n&&(n=!1),void 0===t&&(t=!1),void 0===r&&(r="");var i=n?"[1m":"",o=n?"[22m":"";if(t){var s=Number.isInteger(+this.property)?"["+this.property+"]":(r?".":"")+this.property;return this.constraints?a(s):this.children.map(function(t){return t.toString(n,!0,r+s)}).join("")}return"An instance of "+i+(this.target?this.target.constructor.name:"an object")+o+" has failed the validation:\n"+(this.constraints?a(this.property):"")+this.children.map(function(t){return t.toString(n,!0,e.property)}).join("")},l);function l(){}var d=(p.isValid=function(t){var n=this;return"isValid"!==t&&"getMessage"!==t&&-1!==Object.keys(this).map(function(t){return n[t]}).indexOf(t)},p.CUSTOM_VALIDATION="customValidation",p.NESTED_VALIDATION="nestedValidation",p.PROMISE_VALIDATION="promiseValidation",p.CONDITIONAL_VALIDATION="conditionalValidation",p.WHITELIST="whitelistValidation",p.IS_DEFINED="isDefined",p);function p(){}var v=(m.replaceMessageSpecialTokens=function(t,n){var r;return t instanceof Function?r=t(n):"string"==typeof t&&(r=t),r&&n.constraints instanceof Array&&n.constraints.forEach(function(t,n){r=r.replace(new RegExp("\\$constraint"+(n+1),"g"),t)}),r&&void 0!==n.value&&null!==n.value&&"string"==typeof n.value&&(r=r.replace(/\$value/g,n.value)),r=(r=r&&r.replace(/\$property/g,n.property))&&r.replace(/\$target/g,n.targetName)},m);function m(){}function y(t){return null!==t&&"object"==typeof t&&"function"==typeof t.then}var g=(I.prototype.execute=function(a,t,i){var o=this;this.metadataStorage.hasValidationMetaData||console.warn("No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.");var n=this.validatorOptions?this.validatorOptions.groups:void 0,r=this.metadataStorage.getTargetValidationMetadatas(a.constructor,t,n),s=this.metadataStorage.groupByPropertyName(r);if(this.validatorOptions&&this.validatorOptions.forbidUnknownValues&&!r.length){var e=new f;return this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.target&&!0!==this.validatorOptions.validationError.target||(e.target=a),e.value=void 0,e.property=void 0,e.children=[],e.constraints=["an unknown value was passed to the validate function"],void i.push(e)}this.validatorOptions&&this.validatorOptions.whitelist&&this.whitelist(a,s,i),Object.keys(s).forEach(function(n){var t=a[n],r=s[n].filter(function(t){return t.type===d.IS_DEFINED}),e=s[n].filter(function(t){return t.type!==d.IS_DEFINED&&t.type!==d.WHITELIST});t instanceof Promise&&e.find(function(t){return t.type===d.PROMISE_VALIDATION})?o.awaitingPromises.push(t.then(function(t){o.performValidations(a,t,n,r,e,i)})):o.performValidations(a,t,n,r,e,i)})},I.prototype.whitelist=function(r,n,e){var a=this,i=[];Object.keys(r).forEach(function(t){n[t]&&0!==n[t].length||i.push(t)}),0<i.length&&(this.validatorOptions&&this.validatorOptions.forbidNonWhitelisted?i.forEach(function(t){var n=a.generateValidationError(r,r[t],t);n.constraints=["property "+t+" should not exist"],n.children=void 0,e.push(n)}):i.forEach(function(t){return delete r[t]}))},I.prototype.stripEmptyErrors=function(t){var n=this;return t.filter(function(t){if(t.children&&(t.children=n.stripEmptyErrors(t.children)),0===t.constraints.length){if(0===t.children.length)return!1;delete t.constraints}return!0})},I.prototype.performValidations=function(t,n,r,e,a,i){var o=a.filter(function(t){return t.type===d.CUSTOM_VALIDATION}),s=a.filter(function(t){return t.type===d.NESTED_VALIDATION}),u=a.filter(function(t){return t.type===d.CONDITIONAL_VALIDATION}),c=this.generateValidationError(t,n,r);i.push(c),this.conditionalValidations(t,n,u)&&(this.customValidations(t,n,e,c),void 0===n&&this.validatorOptions&&!0===this.validatorOptions.skipUndefinedProperties||null===n&&this.validatorOptions&&!0===this.validatorOptions.skipNullProperties||null==n&&this.validatorOptions&&!0===this.validatorOptions.skipMissingProperties||(this.customValidations(t,n,o,c),this.nestedValidations(n,s,c.children)))},I.prototype.generateValidationError=function(t,n,r){var e=new f;return this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.target&&!0!==this.validatorOptions.validationError.target||(e.target=t),this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.value&&!0!==this.validatorOptions.validationError.value||(e.value=n),e.property=r,e.children=[],e.constraints=[],e},I.prototype.conditionalValidations=function(n,r,t){return t.map(function(t){return t.constraints[0](n,r)}).reduce(function(t,n){return t&&n},!0)},I.prototype.customValidations=function(d,p,t,v){var m=this;t.forEach(function(l){m.metadataStorage.getTargetValidatorConstraints(l.constraintCls).forEach(function(a){if(!a.async||!m.ignoreAsyncValidations){var n={targetName:d.constructor?d.constructor.name:void 0,property:l.propertyName,object:d,value:p,constraints:l.constraints};if(l.each&&(p instanceof Array||p instanceof Set||p instanceof Map)){var t,r=((t=p)instanceof Map?Array.from(t.values()):Array.isArray(t)?t:Array.from(t)).map(function(t){return a.instance.validate(t,n)});if(r.some(function(t){return y(t)})){var e=r.map(function(t){return y(t)?t:Promise.resolve(t)}),i=Promise.all(e).then(function(t){if(!t.every(function(t){return t})){var n=m.createValidationError(d,p,l,a),r=n[0],e=n[1];v.constraints.push(e),l.context&&(v.contexts||(v.contexts={}),v.contexts[r]=Object.assign(v.contexts[r]||{},l.context))}});m.awaitingPromises.push(i)}else if(!r.every(function(t){return t})){var o=m.createValidationError(d,p,l,a);o[0],f=o[1],v.constraints.push(f)}}else{var s=a.instance.validate(p,n);if(y(s)){var u=s.then(function(t){if(!t){var n=m.createValidationError(d,p,l,a),r=n[0],e=n[1];v.constraints.push(e),l.context&&(v.contexts||(v.contexts={}),v.contexts[r]=Object.assign(v.contexts[r]||{},l.context))}});m.awaitingPromises.push(u)}else if(!s){var c=m.createValidationError(d,p,l,a),f=(c[0],c[1]);v.constraints.push(f)}}}})})},I.prototype.nestedValidations=function(i,o,s){var u=this;void 0!==i&&o.forEach(function(t){if(t.type===d.NESTED_VALIDATION||t.type===d.PROMISE_VALIDATION)if(i instanceof Array||i instanceof Set||i instanceof Map)(i instanceof Set?Array.from(i):i).forEach(function(t,n){u.performValidations(i,t,n.toString(),[],o,s)});else if(i instanceof Object){var n="string"==typeof t.target?t.target:t.target.name;u.execute(i,n,s)}else{var r=new f;r.value=i,r.property=t.propertyName,r.target=t.target;var e=u.createValidationError(t.target,i,t),a=(e[0],e[1]);r.constraints=[a],s.push(r)}})},I.prototype.createValidationError=function(t,n,r,e){var a=t.constructor?t.constructor.name:void 0,i=this.getConstraintType(r,e),o={targetName:a,property:r.propertyName,object:t,value:n,constraints:r.constraints},s=r.message||"";return r.message||this.validatorOptions&&(!this.validatorOptions||this.validatorOptions.dismissDefaultMessages)||e&&e.instance.defaultMessage instanceof Function&&(s=e.instance.defaultMessage(o)),[i,v.replaceMessageSpecialTokens(s,o)]},I.prototype.getConstraintType=function(t,n){return n&&n.name?n.name:t.type},I);function I(t,n){this.validator=t,this.validatorOptions=n,this.awaitingPromises=[],this.ignoreAsyncValidations=!1,this.metadataStorage=s()}var h=(S.prototype.coreValidate=function(t,n,r){var e="string"==typeof t?n:t,a="string"==typeof t?t:void 0,i=new g(this,"string"==typeof t?r:n),o=[];return i.execute(e,a,o),Promise.all(i.awaitingPromises).then(function(){return i.stripEmptyErrors(o)})},S.prototype.validate=function(t,n,r){return this.coreValidate(t,n,r)},S.prototype.validateOrReject=function(r,e,a){return i.__awaiter(this,void 0,void 0,function(){var n;return i.__generator(this,function(t){switch(t.label){case 0:return[4,this.coreValidate(r,e,a)];case 1:return(n=t.sent()).length?[2,Promise.reject(n)]:[2]}})})},S.prototype.validateSync=function(t,n,r){var e="string"==typeof t?n:t,a="string"==typeof t?t:void 0,i=new g(this,"string"==typeof t?r:n);i.ignoreAsyncValidations=!0;var o=[];return i.execute(e,a,o),i.stripEmptyErrors(o)},S);function S(){}var M,b,A=(N.prototype.get=function(n){var t=this.instances.find(function(t){return t.type===n});return t||(t={type:n,object:new n},this.instances.push(t)),t.object},new N);function N(){this.instances=[]}function O(t){if(M)try{var n=M.get(t);if(n)return n;if(!b||!b.fallback)return n}catch(t){if(!b||!b.fallbackOnErrors)throw t}return A.get(t)}var E=(Object.defineProperty(_.prototype,"instance",{get:function(){return O(this.target)},enumerable:!0,configurable:!0}),_);function _(t,n,r){void 0===r&&(r=!1),this.target=t,this.name=n,this.async=r}function $(t){var n;if(t.validator instanceof Function){if(n=t.validator,1<O(u).getTargetValidatorConstraints(t.validator).length)throw"More than one implementation of ValidatorConstraintInterface found for validator on: "+t.target+":"+t.propertyName}else{var r=t.validator;e.prototype.validate=function(t,n){return r.validate(t,n)},e.prototype.defaultMessage=function(t){return r.defaultMessage?r.defaultMessage(t):""},n=e,s().addConstraintMetadata(new E(n,t.name,t.async))}function e(){}var a={type:t.name&&d.isValid(t.name)?t.name:d.CUSTOM_VALIDATION,target:t.target,propertyName:t.propertyName,validationOptions:t.options,constraintCls:n,constraints:t.constraints};s().addValidationMetadata(new o(a))}function T(r,e){return function(t){var n=e&&e.each?"each value in ":"";return r(n,t)}}function C(r,e){return function(t,n){$({name:r.name,target:t.constructor,propertyName:n,options:e,constraints:r.constraints,validator:r.validator})}}var D=d.IS_DEFINED;function L(t){return null!=t}var V="isLatLong";function R(t){return"string"==typeof t&&e.isLatLong(t)}var P="isLatitude";function w(t){return("number"==typeof t||"string"==typeof t)&&R(t+",0")}var B="isLongitude";function x(t){return("number"==typeof t||"string"==typeof t)&&R("0,"+t)}var U="equals";function H(t,n){return t===n}var j="notEquals";function F(t,n){return t!==n}var W="isEmpty";function q(t){return""===t||null==t}var Y="isNotEmpty";function k(t){return""!==t&&null!=t}function G(n,t){return!(t instanceof Array)||t.some(function(t){return t===n})}var J="isNotIn";function z(n,t){return!(t instanceof Array&&t.some(function(t){return t===n}))}var Q="isDivisibleBy";function X(t,n){return"number"==typeof t&&"number"==typeof n&&e.isDivisibleBy(String(t),n)}var Z="isPositive";function K(t){return"number"==typeof t&&0<t}var tt="isNegative";function nt(t){return"number"==typeof t&&t<0}function rt(t,n){return"number"==typeof t&&"number"==typeof n&&t<=n}function et(t,n){return"number"==typeof t&&"number"==typeof n&&n<=t}var at="minDate";function it(t,n){return t instanceof Date&&t.getTime()>=n.getTime()}var ot="maxDate";function st(t,n){return t instanceof Date&&t.getTime()<=n.getTime()}var ut="contains";function ct(t,n){return"string"==typeof t&&e.contains(t,n)}var ft="notContains";function lt(t,n){return"string"==typeof t&&!e.contains(t,n)}var dt="isAlpha";function pt(t,n){return"string"==typeof t&&e.isAlpha(t,n)}var vt="isAlphanumeric";function mt(t,n){return"string"==typeof t&&e.isAlphanumeric(t,n)}var yt="isDecimal";function gt(t,n){return"string"==typeof t&&e.isDecimal(t,n)}var It="isAscii";function ht(t){return"string"==typeof t&&e.isAscii(t)}var St="isBase64";function Mt(t){return"string"==typeof t&&e.isBase64(t)}var bt="isByteLength";function At(t,n,r){return"string"==typeof t&&e.isByteLength(t,{min:n,max:r})}var Nt="isCreditCard";function Ot(t){return"string"==typeof t&&e.isCreditCard(t)}var Et="isCurrency";function _t(t,n){return"string"==typeof t&&e.isCurrency(t,n)}var $t="isEmail";function Tt(t,n){return"string"==typeof t&&e.isEmail(t,n)}function Ct(t,n){return"string"==typeof t&&e.isFQDN(t,n)}var Dt="isFullWidth";function Lt(t){return"string"==typeof t&&e.isFullWidth(t)}var Vt="isHalfWidth";function Rt(t){return"string"==typeof t&&e.isHalfWidth(t)}var Pt="isVariableWidth";function wt(t){return"string"==typeof t&&e.isVariableWidth(t)}var Bt="isHexColor";function xt(t){return"string"==typeof t&&e.isHexColor(t)}var Ut="isHexadecimal";function Ht(t){return"string"==typeof t&&e.isHexadecimal(t)}function jt(t){return!!t&&("each"in t||"message"in t||"groups"in t||"always"in t||"context"in t)}var Ft="isMacAddress";function Wt(t,n){return"string"==typeof t&&e.isMACAddress(t,n)}function qt(t,n){var r=n?""+n:void 0;return"string"==typeof t&&e.isIP(t,r)}function Yt(t){return"string"==typeof t&&e.isPort(t)}function kt(t,n){var r=n?""+n:void 0;return"string"==typeof t&&e.isISBN(t,r)}function Gt(t){return"string"==typeof t&&e.isISIN(t)}var Jt="isIso8601";function zt(t,n){return"string"==typeof t&&e.isISO8601(t,n)}function Qt(t){return"string"==typeof t&&e.isJSON(t)}function Xt(t){return"string"==typeof t&&e.isJWT(t)}var Zt="isLowercase";function Kt(t){return"string"==typeof t&&e.isLowercase(t)}var tn="isMobilePhone";function nn(t,n,r){return"string"==typeof t&&e.isMobilePhone(t,n,r)}var rn="isISO31661Alpha2";function en(t){return"string"==typeof t&&e.isISO31661Alpha2(t)}var an="isISO31661Alpha3";function on(t){return"string"==typeof t&&e.isISO31661Alpha3(t)}var sn="isMongoId";function un(t){return"string"==typeof t&&e.isMongoId(t)}var cn="isMultibyte";function fn(t){return"string"==typeof t&&e.isMultibyte(t)}var ln="isSurrogatePair";function dn(t){return"string"==typeof t&&e.isSurrogatePair(t)}function pn(t,n){return"string"==typeof t&&e.isURL(t,n)}function vn(t,n){return"string"==typeof t&&e.isUUID(t,n)}var mn="IsFirebasePushId";function yn(t){return"string"==typeof t&&20===t.length&&/^[a-zA-Z0-9_-]*$/.test(t)}var gn="isUppercase";function In(t){return"string"==typeof t&&e.isUppercase(t)}function hn(t,n,r){return"string"==typeof t&&e.isLength(t,{min:n,max:r})}var Sn="maxLength";function Mn(t,n){return"string"==typeof t&&e.isLength(t,{min:0,max:n})}var bn="minLength";function An(t,n){return"string"==typeof t&&e.isLength(t,{min:n})}var Nn="matches";function On(t,n,r){return"string"==typeof t&&e.matches(t,n,r)}var En="isPhoneNumber";function _n(t,n){var r=a.PhoneNumberUtil.getInstance();try{var e=r.parseAndKeepRawInput(t,n);return r.isValidNumber(e)}catch(t){return!1}}var $n="isMilitaryTime";function Tn(t){return"string"==typeof t&&e.matches(t,/^([01]\d|2[0-3]):?([0-5]\d)$/)}function Cn(t,n){return"string"==typeof t&&e.isHash(t,n)}function Dn(t,n){return"string"==typeof t&&e.isISSN(t,n)}var Ln="isDateString";function Vn(t){return"string"==typeof t&&/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:Z|[\+\-][0-2]\d(?:\:[0-5]\d)?)?$/g.test(t)}var Rn="isBooleanString";function Pn(t){return"string"==typeof t&&e.isBoolean(t)}var wn="isNumberString";function Bn(t,n){return"string"==typeof t&&e.isNumeric(t,n)}var xn="isBase32";function Un(t){return"string"==typeof t&&e.isBase32(t)}function Hn(t){return"string"==typeof t&&e.isBIC(t)}var jn="isBtcAddress";function Fn(t){return"string"==typeof t&&e.isBtcAddress(t)}var Wn="isDataURI";function qn(t){return"string"==typeof t&&e.isDataURI(t)}function Yn(t){return"string"==typeof t&&e.isEAN(t)}var kn="isEthereumAddress";function Gn(t){return"string"==typeof t&&e.isEthereumAddress(t)}function Jn(t){return"string"==typeof t&&e.isHSL(t)}function zn(t){return"string"==typeof t&&e.isIBAN(t)}var Qn="isIdentityCard";function Xn(t,n){return"string"==typeof t&&e.isIdentityCard(t,n)}function Zn(t){return"string"==typeof t&&e.isISRC(t)}var Kn="isLocale";function tr(t){return"string"==typeof t&&e.isLocale(t)}var nr="isMagnetURI";function rr(t){return"string"==typeof t&&e.isMagnetURI(t)}var er="isMimeType";function ar(t){return"string"==typeof t&&e.isMimeType(t)}var ir="isOctal";function or(t){return"string"==typeof t&&e.isOctal(t)}var sr="isPassportNumber";function ur(t,n){return"string"==typeof t&&e.isPassportNumber(t,n)}var cr="isPostalCode";function fr(t,n){return"string"==typeof t&&e.isPostalCode(t,n)}var lr="isRFC3339";function dr(t){return"string"==typeof t&&e.isRFC3339(t)}var pr="isRgbColor";function vr(t,n){return"string"==typeof t&&e.isRgbColor(t,n)}var mr="isSemVer";function yr(t){return"string"==typeof t&&e.isSemVer(t)}var gr="isBoolean";function Ir(t){return t instanceof Boolean||"boolean"==typeof t}function hr(t){return t instanceof Date&&!isNaN(t.getTime())}var Sr="isNumber";function Mr(t,n){if(void 0===n&&(n={}),"number"!=typeof t)return!1;if(t===1/0||t===-1/0)return n.allowInfinity;if(Number.isNaN(t))return n.allowNaN;if(void 0!==n.maxDecimalPlaces){var r=0;if(t%1!=0&&(r=t.toString().split(".")[1].length),r>n.maxDecimalPlaces)return!1}return Number.isFinite(t)}function br(t,n){return 0<=Object.keys(n).map(function(t){return n[t]}).indexOf(t)}function Ar(t){return"number"==typeof t&&Number.isInteger(t)}var Nr="isString";function Or(t){return t instanceof String||"string"==typeof t}var Er="isArray";function _r(t){return t instanceof Array}var $r="isObject";function Tr(t){return null!=t&&("object"==typeof t||"function"==typeof t)&&!Array.isArray(t)}var Cr="arrayContains";function Dr(n,t){return n instanceof Array&&t.every(function(t){return-1!==n.indexOf(t)})}var Lr="arrayNotContains";function Vr(n,t){return n instanceof Array&&t.every(function(t){return-1===n.indexOf(t)})}var Rr="arrayNotEmpty";function Pr(t){return t instanceof Array&&0<t.length}var wr="arrayMinSize";function Br(t,n){return t instanceof Array&&t.length>=n}var xr="arrayMaxSize";function Ur(t,n){return t instanceof Array&&t.length<=n}var Hr="arrayUnique";function jr(t){if(!(t instanceof Array))return!1;var n=t.filter(function(t,n,r){return r.indexOf(t)===n});return t.length===n.length}var Fr="isNotEmptyObject";function Wr(t){if(!Tr(t))return!1;for(var n in t)if(t.hasOwnProperty(n))return!0;return!1}var qr="isInstance";function Yr(t,n){return n&&"function"==typeof n&&t instanceof n}t.ARRAY_CONTAINS=Cr,t.ARRAY_MAX_SIZE=xr,t.ARRAY_MIN_SIZE=wr,t.ARRAY_NOT_CONTAINS=Lr,t.ARRAY_NOT_EMPTY=Rr,t.ARRAY_UNIQUE=Hr,t.Allow=function(e){return function(t,n){var r={type:d.WHITELIST,target:t.constructor,propertyName:n,validationOptions:e};s().addValidationMetadata(new o(r))}},t.ArrayContains=function(t,n){return C({name:Cr,constraints:[t],validator:{validate:function(t,n){return Dr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain $constraint1 values"},n)}},n)},t.ArrayMaxSize=function(t,n){return C({name:xr,constraints:[t],validator:{validate:function(t,n){return Ur(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain not more than $constraint1 elements"},n)}},n)},t.ArrayMinSize=function(t,n){return C({name:wr,constraints:[t],validator:{validate:function(t,n){return Br(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain at least $constraint1 elements"},n)}},n)},t.ArrayNotContains=function(t,n){return C({name:Lr,constraints:[t],validator:{validate:function(t,n){return Vr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property should not contain $constraint1 values"},n)}},n)},t.ArrayNotEmpty=function(t){return C({name:Rr,validator:{validate:function(t,n){return Pr(t)},defaultMessage:T(function(t){return t+"$property should not be empty"},t)}},t)},t.ArrayUnique=function(t){return C({name:Hr,validator:{validate:function(t,n){return jr(t)},defaultMessage:T(function(t){return t+"All $property's elements must be unique"},t)}},t)},t.CONTAINS=ut,t.Contains=function(t,n){return C({name:ut,constraints:[t],validator:{validate:function(t,n){return ct(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain a $constraint1 string"},n)}},n)},t.EQUALS=U,t.Equals=function(t,n){return C({name:U,constraints:[t],validator:{validate:function(t,n){return H(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be equal to $constraint1"},n)}},n)},t.IS_ALPHA=dt,t.IS_ALPHANUMERIC=vt,t.IS_ARRAY=Er,t.IS_ASCII=It,t.IS_BASE32=xn,t.IS_BASE64=St,t.IS_BIC="isBIC",t.IS_BOOLEAN=gr,t.IS_BOOLEAN_STRING=Rn,t.IS_BTC_ADDRESS=jn,t.IS_BYTE_LENGTH=bt,t.IS_CREDIT_CARD=Nt,t.IS_CURRENCY=Et,t.IS_DATA_URI=Wn,t.IS_DATE="isDate",t.IS_DATE_STRING=Ln,t.IS_DECIMAL=yt,t.IS_DEFINED=D,t.IS_DIVISIBLE_BY=Q,t.IS_EAN="isEAN",t.IS_EMAIL=$t,t.IS_EMPTY=W,t.IS_ENUM="isEnum",t.IS_ETHEREUM_ADDRESS=kn,t.IS_FIREBASE_PUSH_ID=mn,t.IS_FQDN="isFqdn",t.IS_FULL_WIDTH=Dt,t.IS_HALF_WIDTH=Vt,t.IS_HASH="isHash",t.IS_HEXADECIMAL=Ut,t.IS_HEX_COLOR=Bt,t.IS_HSL="isHSL",t.IS_IBAN="isIBAN",t.IS_IDENTITY_CARD=Qn,t.IS_IN="isIn",t.IS_INSTANCE=qr,t.IS_INT="isInt",t.IS_IP="isIp",t.IS_ISBN="isIsbn",t.IS_ISIN="isIsin",t.IS_ISO31661_ALPHA_2=rn,t.IS_ISO31661_ALPHA_3=an,t.IS_ISO8601=Jt,t.IS_ISRC="isISRC",t.IS_ISSN="isISSN",t.IS_JSON="isJson",t.IS_JWT="isJwt",t.IS_LATITUDE=P,t.IS_LATLONG=V,t.IS_LOCALE=Kn,t.IS_LONGITUDE=B,t.IS_LOWERCASE=Zt,t.IS_MAC_ADDRESS=Ft,t.IS_MAGNET_URI=nr,t.IS_MILITARY_TIME=$n,t.IS_MIME_TYPE=er,t.IS_MOBILE_PHONE=tn,t.IS_MONGO_ID=sn,t.IS_MULTIBYTE=cn,t.IS_NEGATIVE=tt,t.IS_NOT_EMPTY=Y,t.IS_NOT_EMPTY_OBJECT=Fr,t.IS_NOT_IN=J,t.IS_NUMBER=Sr,t.IS_NUMBER_STRING=wn,t.IS_OBJECT=$r,t.IS_OCTAL=ir,t.IS_PASSPORT_NUMBER=sr,t.IS_PHONE_NUMBER=En,t.IS_PORT="isPort",t.IS_POSITIVE=Z,t.IS_POSTAL_CODE=cr,t.IS_RFC_3339=lr,t.IS_RGB_COLOR=pr,t.IS_SEM_VER=mr,t.IS_STRING=Nr,t.IS_SURROGATE_PAIR=ln,t.IS_UPPERCASE=gn,t.IS_URL="isUrl",t.IS_UUID="isUuid",t.IS_VARIABLE_WIDTH=Pt,t.IsAlpha=function(t,n){return C({name:dt,constraints:[t],validator:{validate:function(t,n){return pt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain only letters (a-zA-Z)"},n)}},n)},t.IsAlphanumeric=function(t,n){return C({name:vt,constraints:[t],validator:{validate:function(t,n){return mt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must contain only letters and numbers"},n)}},n)},t.IsArray=function(t){return C({name:Er,validator:{validate:function(t,n){return _r(t)},defaultMessage:T(function(t){return t+"$property must be an array"},t)}},t)},t.IsAscii=function(t){return C({name:It,validator:{validate:function(t,n){return ht(t)},defaultMessage:T(function(t){return t+"$property must contain only ASCII characters"},t)}},t)},t.IsBIC=function(t){return C({name:"isBIC",validator:{validate:function(t,n){return Hn(t)},defaultMessage:T(function(t){return t+"$property must be a BIC or SWIFT code"},t)}},t)},t.IsBase32=function(t){return C({name:xn,validator:{validate:function(t,n){return Un(t)},defaultMessage:T(function(t){return t+"$property must be base32 encoded"},t)}},t)},t.IsBase64=function(t){return C({name:St,validator:{validate:function(t,n){return Mt(t)},defaultMessage:T(function(t){return t+"$property must be base64 encoded"},t)}},t)},t.IsBoolean=function(t){return C({name:gr,validator:{validate:function(t,n){return Ir(t)},defaultMessage:T(function(t){return t+"$property must be a boolean value"},t)}},t)},t.IsBooleanString=function(t){return C({name:Rn,validator:{validate:function(t,n){return Pn(t)},defaultMessage:T(function(t){return t+"$property must be a boolean string"},t)}},t)},t.IsBtcAddress=function(t){return C({name:jn,validator:{validate:function(t,n){return Fn(t)},defaultMessage:T(function(t){return t+"$property must be a BTC address"},t)}},t)},t.IsByteLength=function(t,n,r){return C({name:bt,constraints:[t,n],validator:{validate:function(t,n){return At(t,n.constraints[0],n.constraints[1])},defaultMessage:T(function(t){return t+"$property's byte length must fall into ($constraint1, $constraint2) range"},r)}},r)},t.IsCreditCard=function(t){return C({name:Nt,validator:{validate:function(t,n){return Ot(t)},defaultMessage:T(function(t){return t+"$property must be a credit card"},t)}},t)},t.IsCurrency=function(t,n){return C({name:Et,constraints:[t],validator:{validate:function(t,n){return _t(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a currency"},n)}},n)},t.IsDataURI=function(t){return C({name:Wn,validator:{validate:function(t,n){return qn(t)},defaultMessage:T(function(t){return t+"$property must be a data uri format"},t)}},t)},t.IsDate=function(t){return C({name:"isDate",validator:{validate:function(t,n){return hr(t)},defaultMessage:T(function(t){return t+"$property must be a Date instance"},t)}},t)},t.IsDateString=function(t){return C({name:Ln,validator:{validate:function(t,n){return Vn(t)},defaultMessage:T(function(t){return t+"$property must be a ISOString"},t)}},t)},t.IsDecimal=function(t,n){return C({name:yt,constraints:[t],validator:{validate:function(t,n){return gt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property is not a valid decimal number."},n)}},n)},t.IsDefined=function(t){return C({name:D,validator:{validate:function(t){return L(t)},defaultMessage:T(function(t){return t+"$property should not be null or undefined"},t)}},t)},t.IsDivisibleBy=function(t,n){return C({name:Q,constraints:[t],validator:{validate:function(t,n){return X(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be divisible by $constraint1"},n)}},n)},t.IsEAN=function(t){return C({name:"isEAN",validator:{validate:function(t,n){return Yn(t)},defaultMessage:T(function(t){return t+"$property must be an EAN (European Article Number)"},t)}},t)},t.IsEmail=function(t,n){return C({name:$t,constraints:[t],validator:{validate:function(t,n){return Tt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be an email"},n)}},n)},t.IsEmpty=function(t){return C({name:W,validator:{validate:function(t,n){return q(t)},defaultMessage:T(function(t){return t+"$property must be empty"},t)}},t)},t.IsEnum=function(t,n){return C({name:"isEnum",constraints:[t],validator:{validate:function(t,n){return br(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a valid enum value"},n)}},n)},t.IsEthereumAddress=function(t){return C({name:kn,validator:{validate:function(t,n){return Gn(t)},defaultMessage:T(function(t){return t+"$property must be an Ethereum address"},t)}},t)},t.IsFQDN=function(t,n){return C({name:"isFqdn",constraints:[t],validator:{validate:function(t,n){return Ct(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a valid domain name"},n)}},n)},t.IsFirebasePushId=function(t){return C({name:mn,validator:{validate:function(t,n){return yn(t)},defaultMessage:T(function(t){return t+"$property must be a Firebase Push Id"},t)}},t)},t.IsFullWidth=function(t){return C({name:Dt,validator:{validate:function(t,n){return Lt(t)},defaultMessage:T(function(t){return t+"$property must contain a full-width characters"},t)}},t)},t.IsHSL=function(t){return C({name:"isHSL",validator:{validate:function(t,n){return Jn(t)},defaultMessage:T(function(t){return t+"$property must be a HSL color"},t)}},t)},t.IsHalfWidth=function(t){return C({name:Vt,validator:{validate:function(t,n){return Rt(t)},defaultMessage:T(function(t){return t+"$property must contain a half-width characters"},t)}},t)},t.IsHash=function(t,n){return C({name:"isHash",constraints:[t],validator:{validate:function(t,n){return Cn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a hash of type $constraint1"},n)}},n)},t.IsHexColor=function(t){return C({name:Bt,validator:{validate:function(t,n){return xt(t)},defaultMessage:T(function(t){return t+"$property must be a hexadecimal color"},t)}},t)},t.IsHexadecimal=function(t){return C({name:Ut,validator:{validate:function(t,n){return Ht(t)},defaultMessage:T(function(t){return t+"$property must be a hexadecimal number"},t)}},t)},t.IsIBAN=function(t){return C({name:"isIBAN",validator:{validate:function(t,n){return zn(t)},defaultMessage:T(function(t){return t+"$property must be an IBAN"},t)}},t)},t.IsIP=function(t,n){return C({name:"isIp",constraints:[t],validator:{validate:function(t,n){return qt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be an ip address"},n)}},n)},t.IsISBN=function(t,n){return C({name:"isIsbn",constraints:[t],validator:{validate:function(t,n){return kt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be an ISBN"},n)}},n)},t.IsISIN=function(t){return C({name:"isIsin",validator:{validate:function(t,n){return Gt(t)},defaultMessage:T(function(t){return t+"$property must be an ISIN (stock/security identifier)"},t)}},t)},t.IsISO31661Alpha2=function(t){return C({name:rn,validator:{validate:function(t,n){return en(t)},defaultMessage:T(function(t){return t+"$property must be a valid ISO31661 Alpha2 code"},t)}},t)},t.IsISO31661Alpha3=function(t){return C({name:an,validator:{validate:function(t,n){return on(t)},defaultMessage:T(function(t){return t+"$property must be a valid ISO31661 Alpha3 code"},t)}},t)},t.IsISO8601=function(t,n){return C({name:Jt,constraints:[t],validator:{validate:function(t,n){return zt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a valid ISO 8601 date string"},n)}},n)},t.IsISRC=function(t){return C({name:"isISRC",validator:{validate:function(t,n){return Zn(t)},defaultMessage:T(function(t){return t+"$property must be an ISRC"},t)}},t)},t.IsISSN=function(t,n){return C({name:"isISSN",constraints:[t],validator:{validate:function(t,n){return Dn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a ISSN"},n)}},n)},t.IsIdentityCard=function(t,n){return C({name:Qn,constraints:[t],validator:{validate:function(t,n){return Xn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a identity card number"},n)}},n)},t.IsIn=function(t,n){return C({name:"isIn",constraints:[t],validator:{validate:function(t,n){return G(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be one of the following values: $constraint1"},n)}},n)},t.IsInstance=function(t,n){return C({name:qr,constraints:[t],validator:{validate:function(t,n){return Yr(t,n.constraints[0])},defaultMessage:T(function(t,n){return n.constraints[0]?t+("$property must be an instance of "+n.constraints[0].name):t+qr+" decorator expects and object as value, but got falsy value."},n)}},n)},t.IsInt=function(t){return C({name:"isInt",validator:{validate:function(t,n){return Ar(t)},defaultMessage:T(function(t){return t+"$property must be an integer number"},t)}},t)},t.IsJSON=function(t){return C({name:"isJson",validator:{validate:function(t,n){return Qt(t)},defaultMessage:T(function(t){return t+"$property must be a json string"},t)}},t)},t.IsJWT=function(t){return C({name:"isJwt",validator:{validate:function(t,n){return Xt(t)},defaultMessage:T(function(t){return t+"$property must be a jwt string"},t)}},t)},t.IsLatLong=function(t){return C({name:V,validator:{validate:function(t,n){return R(t)},defaultMessage:T(function(t){return t+"$property must be a latitude,longitude string"},t)}},t)},t.IsLatitude=function(t){return C({name:P,validator:{validate:function(t,n){return w(t)},defaultMessage:T(function(t){return t+"$property must be a latitude string or number"},t)}},t)},t.IsLocale=function(t){return C({name:Kn,validator:{validate:function(t,n){return tr(t)},defaultMessage:T(function(t){return t+"$property must be locale"},t)}},t)},t.IsLongitude=function(t){return C({name:B,validator:{validate:function(t,n){return x(t)},defaultMessage:T(function(t){return t+"$property must be a longitude string or number"},t)}},t)},t.IsLowercase=function(t){return C({name:Zt,validator:{validate:function(t,n){return Kt(t)},defaultMessage:T(function(t){return t+"$property must be a lowercase string"},t)}},t)},t.IsMACAddress=function(t,n){var r=jt(t)?void 0:t,e=jt(t)?t:n;return C({name:Ft,constraints:[r],validator:{validate:function(t,n){return Wt(t,r)},defaultMessage:T(function(t){return t+"$property must be a MAC Address"},e)}},e)},t.IsMagnetURI=function(t){return C({name:nr,validator:{validate:function(t,n){return rr(t)},defaultMessage:T(function(t){return t+"$property must be magnet uri format"},t)}},t)},t.IsMilitaryTime=function(t){return C({name:$n,validator:{validate:function(t,n){return Tn(t)},defaultMessage:T(function(t){return t+"$property must be a valid representation of military time in the format HH:MM"},t)}},t)},t.IsMimeType=function(t){return C({name:er,validator:{validate:function(t,n){return ar(t)},defaultMessage:T(function(t){return t+"$property must be MIME type format"},t)}},t)},t.IsMobilePhone=function(t,n,r){return C({name:tn,constraints:[t,n],validator:{validate:function(t,n){return nn(t,n.constraints[0],n.constraints[1])},defaultMessage:T(function(t){return t+"$property must be a phone number"},r)}},r)},t.IsMongoId=function(t){return C({name:sn,validator:{validate:function(t,n){return un(t)},defaultMessage:T(function(t){return t+"$property must be a mongodb id"},t)}},t)},t.IsMultibyte=function(t){return C({name:cn,validator:{validate:function(t,n){return fn(t)},defaultMessage:T(function(t){return t+"$property must contain one or more multibyte chars"},t)}},t)},t.IsNegative=function(t){return C({name:tt,validator:{validate:function(t,n){return nt(t)},defaultMessage:T(function(t){return t+"$property must be a negative number"},t)}},t)},t.IsNotEmpty=function(t){return C({name:Y,validator:{validate:function(t,n){return k(t)},defaultMessage:T(function(t){return t+"$property should not be empty"},t)}},t)},t.IsNotEmptyObject=function(t){return C({name:Fr,validator:{validate:function(t,n){return Wr(t)},defaultMessage:T(function(t){return t+"$property must be a non-empty object"},t)}},t)},t.IsNotIn=function(t,n){return C({name:J,constraints:[t],validator:{validate:function(t,n){return z(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property should not be one of the following values: $constraint1"},n)}},n)},t.IsNumber=function(t,n){return void 0===t&&(t={}),C({name:Sr,constraints:[t],validator:{validate:function(t,n){return Mr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a number conforming to the specified constraints"},n)}},n)},t.IsNumberString=function(t,n){return C({name:wn,constraints:[t],validator:{validate:function(t,n){return Bn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a number string"},n)}},n)},t.IsObject=function(t){return C({name:$r,validator:{validate:function(t,n){return Tr(t)},defaultMessage:T(function(t){return t+"$property must be an object"},t)}},t)},t.IsOctal=function(t){return C({name:ir,validator:{validate:function(t,n){return or(t)},defaultMessage:T(function(t){return t+"$property must be valid octal number"},t)}},t)},t.IsOptional=function(e){return function(t,r){var n={type:d.CONDITIONAL_VALIDATION,target:t.constructor,propertyName:r,constraints:[function(t,n){return null!==t[r]&&void 0!==t[r]}],validationOptions:e};s().addValidationMetadata(new o(n))}},t.IsPassportNumber=function(t,n){return C({name:sr,constraints:[t],validator:{validate:function(t,n){return ur(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be valid passport number"},n)}},n)},t.IsPhoneNumber=function(t,n){return C({name:En,constraints:[t],validator:{validate:function(t,n){return _n(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a valid phone number"},n)}},n)},t.IsPort=function(t){return C({name:"isPort",validator:{validate:function(t,n){return Yt(t)},defaultMessage:T(function(t){return t+"$property must be a port"},t)}},t)},t.IsPositive=function(t){return C({name:Z,validator:{validate:function(t,n){return K(t)},defaultMessage:T(function(t){return t+"$property must be a positive number"},t)}},t)},t.IsPostalCode=function(t,n){return C({name:cr,constraints:[t],validator:{validate:function(t,n){return fr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be a postal code"},n)}},n)},t.IsRFC3339=function(t){return C({name:lr,validator:{validate:function(t,n){return dr(t)},defaultMessage:T(function(t){return t+"$property must be RFC 3339 date"},t)}},t)},t.IsRgbColor=function(t,n){return C({name:pr,constraints:[t],validator:{validate:function(t,n){return vr(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be RGB color"},n)}},n)},t.IsSemVer=function(t){return C({name:mr,validator:{validate:function(t,n){return yr(t)},defaultMessage:T(function(t){return t+"$property must be a Semantic Versioning Specification"},t)}},t)},t.IsString=function(t){return C({name:Nr,validator:{validate:function(t,n){return Or(t)},defaultMessage:T(function(t){return t+"$property must be a string"},t)}},t)},t.IsSurrogatePair=function(t){return C({name:ln,validator:{validate:function(t,n){return dn(t)},defaultMessage:T(function(t){return t+"$property must contain any surrogate pairs chars"},t)}},t)},t.IsUUID=function(t,n){return C({name:"isUuid",constraints:[t],validator:{validate:function(t,n){return vn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be an UUID"},n)}},n)},t.IsUppercase=function(t){return C({name:gn,validator:{validate:function(t,n){return In(t)},defaultMessage:T(function(t){return t+"$property must be uppercase"},t)}},t)},t.IsUrl=function(t,n){return C({name:"isUrl",constraints:[t],validator:{validate:function(t,n){return pn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be an URL address"},n)}},n)},t.IsVariableWidth=function(t){return C({name:Pt,validator:{validate:function(t,n){return wt(t)},defaultMessage:T(function(t){return t+"$property must contain a full-width and half-width characters"},t)}},t)},t.LENGTH="length",t.Length=function(t,n,r){return C({name:"length",constraints:[t,n],validator:{validate:function(t,n){return hn(t,n.constraints[0],n.constraints[1])},defaultMessage:T(function(t,n){var r=null!==n.constraints[0]&&void 0!==n.constraints[0],e=null!==n.constraints[1]&&void 0!==n.constraints[1];return r&&(!n.value||n.value.length<n.constraints[0])?t+"$property must be longer than or equal to $constraint1 characters":e&&n.value.length>n.constraints[1]?t+"$property must be shorter than or equal to $constraint2 characters":t+"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters"},r)}},r)},t.MATCHES=Nn,t.MAX="max",t.MAX_DATE=ot,t.MAX_LENGTH=Sn,t.MIN="min",t.MIN_DATE=at,t.MIN_LENGTH=bn,t.Matches=function(t,n,r){var e;return n&&n instanceof Object&&!r?r=n:e=n,C({name:Nn,constraints:[t,e],validator:{validate:function(t,n){return On(t,n.constraints[0],n.constraints[0])},defaultMessage:T(function(t,n){return t+"$property must match $constraint1 regular expression"},r)}},r)},t.Max=function(t,n){return C({name:"max",constraints:[t],validator:{validate:function(t,n){return rt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must not be greater than $constraint1"},n)}},n)},t.MaxDate=function(t,n){return C({name:ot,constraints:[t],validator:{validate:function(t,n){return st(t,n.constraints[0])},defaultMessage:T(function(t){return"maximal allowed date for "+t+"$property is $constraint1"},n)}},n)},t.MaxLength=function(t,n){return C({name:Sn,constraints:[t],validator:{validate:function(t,n){return Mn(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be shorter than or equal to $constraint1 characters"},n)}},n)},t.MetadataStorage=u,t.Min=function(t,n){return C({name:"min",constraints:[t],validator:{validate:function(t,n){return et(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must not be less than $constraint1"},n)}},n)},t.MinDate=function(t,n){return C({name:at,constraints:[t],validator:{validate:function(t,n){return it(t,n.constraints[0])},defaultMessage:T(function(t){return"minimal allowed date for "+t+"$property is $constraint1"},n)}},n)},t.MinLength=function(t,n){return C({name:bn,constraints:[t],validator:{validate:function(t,n){return An(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property must be longer than or equal to $constraint1 characters"},n)}},n)},t.NOT_CONTAINS=ft,t.NOT_EQUALS=j,t.NotContains=function(t,n){return C({name:ft,constraints:[t],validator:{validate:function(t,n){return lt(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property should not contain a $constraint1 string"},n)}},n)},t.NotEquals=function(t,n){return C({name:j,constraints:[t],validator:{validate:function(t,n){return F(t,n.constraints[0])},defaultMessage:T(function(t){return t+"$property should not be equal to $constraint1"},n)}},n)},t.Validate=function(e,a,i){return function(t,n){var r={type:d.CUSTOM_VALIDATION,target:t.constructor,propertyName:n,constraintCls:e,constraints:a instanceof Array?a:void 0,validationOptions:a instanceof Array?i:a};s().addValidationMetadata(new o(r))}},t.ValidateBy=C,t.ValidateIf=function(e,a){return function(t,n){var r={type:d.CONDITIONAL_VALIDATION,target:t.constructor,propertyName:n,constraints:[e],validationOptions:a};s().addValidationMetadata(new o(r))}},t.ValidateNested=function(t){var e=i.__assign({},t),n=e.each?"each value in ":"";return e.message=e.message||n+"nested property $property must be either object or array",function(t,n){var r={type:d.NESTED_VALIDATION,target:t.constructor,propertyName:n,validationOptions:e};s().addValidationMetadata(new o(r))}},t.ValidatePromise=function(e){return function(t,n){var r={type:d.PROMISE_VALIDATION,target:t.constructor,propertyName:n,validationOptions:e};s().addValidationMetadata(new o(r))}},t.ValidationError=f,t.ValidationTypes=d,t.Validator=h,t.ValidatorConstraint=function(a){return function(t){var n=!(!a||!a.async),r=a&&a.name?a.name:"";r=r||((r=t.name)||r.replace(/\.?([A-Z]+)/g,function(t,n){return"_"+n.toLowerCase()}).replace(/^_/,""));var e=new E(t,r,n);s().addConstraintMetadata(e)}},t.arrayContains=Dr,t.arrayMaxSize=Ur,t.arrayMinSize=Br,t.arrayNotContains=Vr,t.arrayNotEmpty=Pr,t.arrayUnique=jr,t.buildMessage=T,t.contains=ct,t.equals=H,t.getFromContainer=O,t.getMetadataStorage=s,t.isAlpha=pt,t.isAlphanumeric=mt,t.isArray=_r,t.isAscii=ht,t.isBIC=Hn,t.isBase32=Un,t.isBase64=Mt,t.isBoolean=Ir,t.isBooleanString=Pn,t.isBtcAddress=Fn,t.isByteLength=At,t.isCreditCard=Ot,t.isCurrency=_t,t.isDataURI=qn,t.isDate=hr,t.isDateString=Vn,t.isDecimal=gt,t.isDefined=L,t.isDivisibleBy=X,t.isEAN=Yn,t.isEmail=Tt,t.isEmpty=q,t.isEnum=br,t.isEthereumAddress=Gn,t.isFQDN=Ct,t.isFirebasePushId=yn,t.isFullWidth=Lt,t.isHSL=Jn,t.isHalfWidth=Rt,t.isHash=Cn,t.isHexColor=xt,t.isHexadecimal=Ht,t.isIBAN=zn,t.isIP=qt,t.isISBN=kt,t.isISIN=Gt,t.isISO31661Alpha2=en,t.isISO31661Alpha3=on,t.isISO8601=zt,t.isISRC=Zn,t.isISSN=Dn,t.isIdentityCard=Xn,t.isIn=G,t.isInstance=Yr,t.isInt=Ar,t.isJSON=Qt,t.isJWT=Xt,t.isLatLong=R,t.isLatitude=w,t.isLocale=tr,t.isLongitude=x,t.isLowercase=Kt,t.isMACAddress=Wt,t.isMagnetURI=rr,t.isMilitaryTime=Tn,t.isMimeType=ar,t.isMobilePhone=nn,t.isMongoId=un,t.isMultibyte=fn,t.isNegative=nt,t.isNotEmpty=k,t.isNotEmptyObject=Wr,t.isNotIn=z,t.isNumber=Mr,t.isNumberString=Bn,t.isObject=Tr,t.isOctal=or,t.isPassportNumber=ur,t.isPhoneNumber=_n,t.isPort=Yt,t.isPositive=K,t.isPostalCode=fr,t.isRFC3339=dr,t.isRgbColor=vr,t.isSemVer=yr,t.isString=Or,t.isSurrogatePair=dn,t.isURL=pn,t.isUUID=vn,t.isUppercase=In,t.isValidationOptions=jt,t.isVariableWidth=wt,t.length=hn,t.matches=On,t.max=rt,t.maxDate=st,t.maxLength=Mn,t.min=et,t.minDate=it,t.minLength=An,t.notContains=lt,t.notEquals=F,t.registerDecorator=$,t.registerSchema=function(t){s().addValidationSchema(t)},t.useContainer=function(t,n){M=t,b=n},t.validate=function(t,n,r){return"string"==typeof t?O(h).validate(t,n,r):O(h).validate(t,n)},t.validateOrReject=function(t,n,r){return"string"==typeof t?O(h).validateOrReject(t,n,r):O(h).validateOrReject(t,n)},t.validateSync=function(t,n,r){return"string"==typeof t?O(h).validateSync(t,n,r):O(h).validateSync(t,n)},Object.defineProperty(t,"__esModule",{value:!0})});
 //# sourceMappingURL=index.umd.min.js.map
diff --git a/node_modules/class-validator/bundles/index.umd.min.js.map b/node_modules/class-validator/bundles/index.umd.min.js.map
index 2a8dcd7..a83742f 100644
--- a/node_modules/class-validator/bundles/index.umd.min.js.map
+++ b/node_modules/class-validator/bundles/index.umd.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.umd.min.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/validation/ValidationUtils.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/decorator/common/Allow.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["args","this","undefined","type","target","propertyName","constraints","constraintCls","validationTypeOptions","validationOptions","message","groups","always","each","context","ValidationSchemaToMetadataTransformer","schema","metadatas","Object","keys","properties","forEach","property","validation","name","options","push","ValidationMetadata","getMetadataStorage","window","global","classValidatorMetadataStorage","MetadataStorage","validationMetadatas","length","transform","validationMetadata","_this","addValidationMetadata","metadata","constraintMetadatas","grouped","targetConstructor","targetSchema","originalMetadatas","filter","find","group","indexOf","uniqueInheritedMetadatas","Function","prototype","inheritedMetadata","originalMetadata","concat","ValidationError","shouldDecorate","hasParent","parentPath","propConstraintFailed","boldStart","boldEnd","join","formattedProperty_1","Number","isInteger","children","map","childError","toString","constructor","ValidationTypes","key","ValidationUtils","validationArguments","messageString","Array","constraint","index","replace","RegExp","value","targetName","isPromise","p","then","ValidationExecutor","object","validationErrors","metadataStorage","hasValidationMetaData","console","warn","validatorOptions","targetMetadatas","getTargetValidationMetadatas","groupedMetadatas","groupByPropertyName","forbidUnknownValues","validationError","unknownValue","whitelist","definedMetadatas","IS_DEFINED","WHITELIST","Promise","PROMISE_VALIDATION","awaitingPromises","resolvedValue","performValidations","notAllowedProperties","forbidNonWhitelisted","generateValidationError","errors","error","stripEmptyErrors","customValidationMetadatas","CUSTOM_VALIDATION","nestedValidationMetadatas","NESTED_VALIDATION","conditionalValidationMetadatas","CONDITIONAL_VALIDATION","conditionalValidations","customValidations","mapContexts","skipUndefinedProperties","skipNullProperties","skipMissingProperties","nestedValidations","reduce","resultA","resultB","getTargetValidatorConstraints","customConstraintMetadata","async","ignoreAsyncValidations","Set","Map","val","validatedSubValues","from","values","isArray","subValue","instance","validate","some","validatedSubValue","asyncValidatedSubValues","resolve","asyncValidationIsFinishedPromise","all","flatValidatedValues","every","isValid","_a","contexts","assign","_b","validatedValue","promise","execute","customConstraint","getConstraintType","customValidatorMetadata","dismissDefaultMessages","defaultMessage","replaceMessageSpecialTokens","validator","Validator","objectOrSchemaName","objectOrValidationOptions","maybeValidatorOptions","executor","coreValidate","reject","userContainer","userContainerOptions","defaultContainer","class_1","someClass","instances","getFromContainer","get","fallback","fallbackOnErrors","ConstraintMetadata","registerDecorator","validator_1","CustomConstraint","addConstraintMetadata","validationMetadataArgs","buildMessage","impl","eachPrefix","ValidateBy","isDefined","IS_LATLONG","isLatLong","IS_LATITUDE","isLatitude","IS_LONGITUDE","isLongitude","EQUALS","equals","comparison","NOT_EQUALS","notEquals","IS_EMPTY","isEmpty","IS_NOT_EMPTY","isNotEmpty","isIn","possibleValues","possibleValue","IS_NOT_IN","isNotIn","IS_DIVISIBLE_BY","isDivisibleBy","num","String","IS_POSITIVE","isPositive","IS_NEGATIVE","isNegative","max","min","MIN_DATE","minDate","date","Date","getTime","MAX_DATE","maxDate","CONTAINS","contains","seed","NOT_CONTAINS","notContains","IS_ALPHA","isAlpha","locale","ValidatorJS","IS_ALPHANUMERIC","isAlphanumeric","IS_DECIMAL","isDecimal","IS_ASCII","isAscii","IS_BASE64","isBase64","IS_BYTE_LENGTH","isByteLength","IS_CREDIT_CARD","isCreditCard","IS_CURRENCY","isCurrency","IS_EMAIL","isEmail","isFQDN","IS_FULL_WIDTH","isFullWidth","IS_HALF_WIDTH","isHalfWidth","IS_VARIABLE_WIDTH","isVariableWidth","IS_HEX_COLOR","isHexColor","IS_HEXADECIMAL","isHexadecimal","isValidationOptions","IS_MAC_ADDRESS","isMACAddress","isIP","version","versionStr","isPort","isISBN","isISIN","IS_ISO8601","isISO8601","isJSON","isJWT","IS_LOWERCASE","isLowercase","IS_MOBILE_PHONE","isMobilePhone","IS_ISO31661_ALPHA_2","isISO31661Alpha2","IS_ISO31661_ALPHA_3","isISO31661Alpha3","IS_MONGO_ID","isMongoId","IS_MULTIBYTE","isMultibyte","IS_SURROGATE_PAIR","isSurrogatePair","isURL","isUUID","IS_FIREBASE_PUSH_ID","isFirebasePushId","test","IS_UPPERCASE","isUppercase","isLength","MAX_LENGTH","maxLength","MIN_LENGTH","minLength","MATCHES","matches","pattern","modifiers","IS_PHONE_NUMBER","isPhoneNumber","region","phoneUtil","PhoneNumberUtil","getInstance","phoneNum","parseAndKeepRawInput","isValidNumber","IS_MILITARY_TIME","isMilitaryTime","isHash","algorithm","isISSN","IS_DATE_STRING","isDateString","IS_BOOLEAN_STRING","isBooleanString","isBoolean","IS_NUMBER_STRING","isNumberString","isNumeric","IS_BASE32","isBase32","isBIC","IS_BTC_ADDRESS","isBtcAddress","IS_DATA_URI","isDataURI","isEAN","IS_ETHEREUM_ADDRESS","isEthereumAddress","isHSL","isIBAN","IS_IDENTITY_CARD","isIdentityCard","isISRC","IS_LOCALE","isLocale","IS_MAGNET_URI","isMagnetURI","IS_MIME_TYPE","isMimeType","IS_OCTAL","isOctal","IS_PASSPORT_NUMBER","isPassportNumber","countryCode","IS_POSTAL_CODE","isPostalCode","IS_RFC_3339","isRFC3339","IS_RGB_COLOR","isRgbColor","includePercentValues","IS_SEM_VER","isSemVer","IS_BOOLEAN","Boolean","isDate","isNaN","IS_NUMBER","isNumber","Infinity","allowInfinity","allowNaN","maxDecimalPlaces","decimalPlaces","split","isFinite","isEnum","entity","k","isInt","IS_STRING","isString","IS_ARRAY","IS_OBJECT","isObject","ARRAY_CONTAINS","arrayContains","array","ARRAY_NOT_CONTAINS","arrayNotContains","ARRAY_NOT_EMPTY","arrayNotEmpty","ARRAY_MIN_SIZE","arrayMinSize","ARRAY_MAX_SIZE","arrayMaxSize","ARRAY_UNIQUE","arrayUnique","uniqueItems","a","b","c","IS_NOT_EMPTY_OBJECT","isNotEmptyObject","hasOwnProperty","IS_INSTANCE","isInstance","targetTypeConstructor","targetType","optionsOrValidationOptionsArg","validationOptionsArg","isMinLength","isMaxLength","modifiersOrAnnotationOptions","maxValue","minValue","constraintClass","constraintsOrValidationOptions","maybeValidationOptions","condition","opts","isAsync","x","y","toLowerCase","addValidationSchema","iocContainer","schemaNameOrObject","validateOrReject","validateSync"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.umd.min.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/validation/ValidationUtils.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/decorator/common/Allow.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: string[];\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = [\"an unknown value was passed to the validate function\"];\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = [`property ${property} should not exist`];\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (error.constraints.length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = [];\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints.push(message);\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints.push(message);\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = [message];\n                errors.push(error);\n            }\n        });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["args","this","undefined","type","target","propertyName","constraints","constraintCls","validationTypeOptions","validationOptions","message","groups","always","each","context","ValidationSchemaToMetadataTransformer","schema","metadatas","Object","keys","properties","forEach","property","validation","name","options","push","ValidationMetadata","getMetadataStorage","window","global","classValidatorMetadataStorage","MetadataStorage","validationMetadatas","length","transform","validationMetadata","_this","addValidationMetadata","metadata","constraintMetadatas","grouped","targetConstructor","targetSchema","originalMetadatas","filter","find","group","indexOf","uniqueInheritedMetadatas","Function","prototype","inheritedMetadata","originalMetadata","concat","ValidationError","shouldDecorate","hasParent","parentPath","propConstraintFailed","boldStart","boldEnd","join","formattedProperty_1","Number","isInteger","children","map","childError","toString","constructor","ValidationTypes","key","ValidationUtils","validationArguments","messageString","Array","constraint","index","replace","RegExp","value","targetName","isPromise","p","then","ValidationExecutor","object","validationErrors","metadataStorage","hasValidationMetaData","console","warn","validatorOptions","targetMetadatas","getTargetValidationMetadatas","groupedMetadatas","groupByPropertyName","forbidUnknownValues","validationError","whitelist","definedMetadatas","IS_DEFINED","WHITELIST","Promise","PROMISE_VALIDATION","awaitingPromises","resolvedValue","performValidations","notAllowedProperties","forbidNonWhitelisted","generateValidationError","errors","error","stripEmptyErrors","customValidationMetadatas","CUSTOM_VALIDATION","nestedValidationMetadatas","NESTED_VALIDATION","conditionalValidationMetadatas","CONDITIONAL_VALIDATION","conditionalValidations","customValidations","skipUndefinedProperties","skipNullProperties","skipMissingProperties","nestedValidations","reduce","resultA","resultB","getTargetValidatorConstraints","customConstraintMetadata","async","ignoreAsyncValidations","Set","Map","val","validatedSubValues","from","values","isArray","subValue","instance","validate","some","validatedSubValue","asyncValidatedSubValues","resolve","asyncValidationIsFinishedPromise","all","flatValidatedValues","every","isValid","_a","contexts","assign","_b","validatedValue","promise","execute","customValidatorMetadata","getConstraintType","dismissDefaultMessages","defaultMessage","replaceMessageSpecialTokens","validator","Validator","objectOrSchemaName","objectOrValidationOptions","maybeValidatorOptions","executor","coreValidate","reject","userContainer","userContainerOptions","defaultContainer","class_1","someClass","instances","getFromContainer","get","fallback","fallbackOnErrors","ConstraintMetadata","registerDecorator","validator_1","CustomConstraint","addConstraintMetadata","validationMetadataArgs","buildMessage","impl","eachPrefix","ValidateBy","isDefined","IS_LATLONG","isLatLong","IS_LATITUDE","isLatitude","IS_LONGITUDE","isLongitude","EQUALS","equals","comparison","NOT_EQUALS","notEquals","IS_EMPTY","isEmpty","IS_NOT_EMPTY","isNotEmpty","isIn","possibleValues","possibleValue","IS_NOT_IN","isNotIn","IS_DIVISIBLE_BY","isDivisibleBy","num","String","IS_POSITIVE","isPositive","IS_NEGATIVE","isNegative","max","min","MIN_DATE","minDate","date","Date","getTime","MAX_DATE","maxDate","CONTAINS","contains","seed","NOT_CONTAINS","notContains","IS_ALPHA","isAlpha","locale","ValidatorJS","IS_ALPHANUMERIC","isAlphanumeric","IS_DECIMAL","isDecimal","IS_ASCII","isAscii","IS_BASE64","isBase64","IS_BYTE_LENGTH","isByteLength","IS_CREDIT_CARD","isCreditCard","IS_CURRENCY","isCurrency","IS_EMAIL","isEmail","isFQDN","IS_FULL_WIDTH","isFullWidth","IS_HALF_WIDTH","isHalfWidth","IS_VARIABLE_WIDTH","isVariableWidth","IS_HEX_COLOR","isHexColor","IS_HEXADECIMAL","isHexadecimal","isValidationOptions","IS_MAC_ADDRESS","isMACAddress","isIP","version","versionStr","isPort","isISBN","isISIN","IS_ISO8601","isISO8601","isJSON","isJWT","IS_LOWERCASE","isLowercase","IS_MOBILE_PHONE","isMobilePhone","IS_ISO31661_ALPHA_2","isISO31661Alpha2","IS_ISO31661_ALPHA_3","isISO31661Alpha3","IS_MONGO_ID","isMongoId","IS_MULTIBYTE","isMultibyte","IS_SURROGATE_PAIR","isSurrogatePair","isURL","isUUID","IS_FIREBASE_PUSH_ID","isFirebasePushId","test","IS_UPPERCASE","isUppercase","isLength","MAX_LENGTH","maxLength","MIN_LENGTH","minLength","MATCHES","matches","pattern","modifiers","IS_PHONE_NUMBER","isPhoneNumber","region","phoneUtil","PhoneNumberUtil","getInstance","phoneNum","parseAndKeepRawInput","isValidNumber","IS_MILITARY_TIME","isMilitaryTime","isHash","algorithm","isISSN","IS_DATE_STRING","isDateString","IS_BOOLEAN_STRING","isBooleanString","isBoolean","IS_NUMBER_STRING","isNumberString","isNumeric","IS_BASE32","isBase32","isBIC","IS_BTC_ADDRESS","isBtcAddress","IS_DATA_URI","isDataURI","isEAN","IS_ETHEREUM_ADDRESS","isEthereumAddress","isHSL","isIBAN","IS_IDENTITY_CARD","isIdentityCard","isISRC","IS_LOCALE","isLocale","IS_MAGNET_URI","isMagnetURI","IS_MIME_TYPE","isMimeType","IS_OCTAL","isOctal","IS_PASSPORT_NUMBER","isPassportNumber","countryCode","IS_POSTAL_CODE","isPostalCode","IS_RFC_3339","isRFC3339","IS_RGB_COLOR","isRgbColor","includePercentValues","IS_SEM_VER","isSemVer","IS_BOOLEAN","Boolean","isDate","isNaN","IS_NUMBER","isNumber","Infinity","allowInfinity","allowNaN","maxDecimalPlaces","decimalPlaces","split","isFinite","isEnum","entity","k","isInt","IS_STRING","isString","IS_ARRAY","IS_OBJECT","isObject","ARRAY_CONTAINS","arrayContains","array","ARRAY_NOT_CONTAINS","arrayNotContains","ARRAY_NOT_EMPTY","arrayNotEmpty","ARRAY_MIN_SIZE","arrayMinSize","ARRAY_MAX_SIZE","arrayMaxSize","ARRAY_UNIQUE","arrayUnique","uniqueItems","a","b","c","IS_NOT_EMPTY_OBJECT","isNotEmptyObject","hasOwnProperty","IS_INSTANCE","isInstance","targetTypeConstructor","targetType","optionsOrValidationOptionsArg","validationOptionsArg","isMinLength","isMaxLength","modifiersOrAnnotationOptions","maxValue","minValue","constraintClass","constraintsOrValidationOptions","maybeValidationOptions","condition","opts","isAsync","x","y","toLowerCase","addValidationSchema","iocContainer","schemaNameOrObject","validateOrReject","validateSync"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/class-validator/esm2015/validation/ValidationError.js.map b/node_modules/class-validator/esm2015/validation/ValidationError.js.map
index 479d0dc..8dee045 100644
--- a/node_modules/class-validator/esm2015/validation/ValidationError.js.map
+++ b/node_modules/class-validator/esm2015/validation/ValidationError.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/validation/ValidationError.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,OAAO,eAAe;IAyCxB;;;;;OAKG;IACH,QAAQ,CAAC,iBAA0B,KAAK,EAAE,YAAqB,KAAK,EAAE,aAAqB,EAAE;QACzF,MAAM,SAAS,GAAG,cAAc,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC;QAClD,MAAM,OAAO,GAAG,cAAc,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC;QACjD,MAAM,oBAAoB,GAAG,CAAC,YAAoB,EAAU,EAAE,CAAC,eAAe,SAAS,GAAG,UAAU,GAAG,YAAY,GAAG,OAAO,0CAA0C,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,OAAO,KAAK,CAAC;QAE3O,IAAI,CAAC,SAAS,EAAE;YACZ,OAAO,kBAAkB,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,GAAG,OAAO,+BAA+B;gBAClI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC7D,IAAI,CAAC,QAAQ;qBACR,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;qBAC3E,IAAI,CAAC,EAAE,CAAC,CAAC;SACrB;aAAM;YACH,6DAA6D;YAC7D,MAAM,iBAAiB,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAE/H,IAAI,IAAI,CAAC,WAAW,EAAE;gBAClB,OAAO,oBAAoB,CAAC,iBAAiB,CAAC,CAAC;aAClD;iBAAM;gBACH,OAAO,IAAI,CAAC,QAAQ;qBACf,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,GAAG,UAAU,GAAG,iBAAiB,EAAE,CAAG,CAAC;qBACnG,IAAI,CAAC,EAAE,CAAC,CAAC;aACjB;SACJ;IACL,CAAC;CACJ","file":"ValidationError.js","sourcesContent":["/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n"],"sourceRoot":".."}
\ No newline at end of file
+{"version":3,"sources":["../../src/validation/ValidationError.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,OAAO,eAAe;IAuCxB;;;;;OAKG;IACH,QAAQ,CAAC,iBAA0B,KAAK,EAAE,YAAqB,KAAK,EAAE,aAAqB,EAAE;QACzF,MAAM,SAAS,GAAG,cAAc,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC;QAClD,MAAM,OAAO,GAAG,cAAc,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC;QACjD,MAAM,oBAAoB,GAAG,CAAC,YAAoB,EAAU,EAAE,CAAC,eAAe,SAAS,GAAG,UAAU,GAAG,YAAY,GAAG,OAAO,0CAA0C,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,OAAO,KAAK,CAAC;QAE3O,IAAI,CAAC,SAAS,EAAE;YACZ,OAAO,kBAAkB,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,GAAG,OAAO,+BAA+B;gBAClI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC7D,IAAI,CAAC,QAAQ;qBACR,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;qBAC3E,IAAI,CAAC,EAAE,CAAC,CAAC;SACrB;aAAM;YACH,6DAA6D;YAC7D,MAAM,iBAAiB,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;YAE/H,IAAI,IAAI,CAAC,WAAW,EAAE;gBAClB,OAAO,oBAAoB,CAAC,iBAAiB,CAAC,CAAC;aAClD;iBAAM;gBACH,OAAO,IAAI,CAAC,QAAQ;qBACf,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,GAAG,UAAU,GAAG,iBAAiB,EAAE,CAAG,CAAC;qBACnG,IAAI,CAAC,EAAE,CAAC,CAAC;aACjB;SACJ;IACL,CAAC;CACJ","file":"ValidationError.js","sourcesContent":["/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: string[];\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n"],"sourceRoot":".."}
\ No newline at end of file
diff --git a/node_modules/class-validator/esm2015/validation/ValidationExecutor.js b/node_modules/class-validator/esm2015/validation/ValidationExecutor.js
index c2ff53d..eef8615 100644
--- a/node_modules/class-validator/esm2015/validation/ValidationExecutor.js
+++ b/node_modules/class-validator/esm2015/validation/ValidationExecutor.js
@@ -49,7 +49,7 @@ export class ValidationExecutor {
             validationError.value = undefined;
             validationError.property = undefined;
             validationError.children = [];
-            validationError.constraints = { unknownValue: "an unknown value was passed to the validate function" };
+            validationError.constraints = ["an unknown value was passed to the validate function"];
             validationErrors.push(validationError);
             return;
         }
@@ -82,7 +82,7 @@ export class ValidationExecutor {
                 // throw errors
                 notAllowedProperties.forEach(property => {
                     const validationError = this.generateValidationError(object, object[property], property);
-                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };
+                    validationError.constraints = [`property ${property} should not exist`];
                     validationError.children = undefined;
                     validationErrors.push(validationError);
                 });
@@ -98,7 +98,7 @@ export class ValidationExecutor {
             if (error.children) {
                 error.children = this.stripEmptyErrors(error.children);
             }
-            if (Object.keys(error.constraints).length === 0) {
+            if (error.constraints.length === 0) {
                 if (error.children.length === 0) {
                     return false;
                 }
@@ -124,7 +124,6 @@ export class ValidationExecutor {
         }
         // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not
         this.customValidations(object, value, definedMetadatas, validationError);
-        this.mapContexts(object, value, definedMetadatas, validationError);
         if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {
             return;
         }
@@ -136,8 +135,6 @@ export class ValidationExecutor {
         }
         this.customValidations(object, value, customValidationMetadatas, validationError);
         this.nestedValidations(value, nestedValidationMetadatas, validationError.children);
-        this.mapContexts(object, value, metadatas, validationError);
-        this.mapContexts(object, value, customValidationMetadatas, validationError);
     }
     generateValidationError(object, value, propertyName) {
         const validationError = new ValidationError();
@@ -153,7 +150,7 @@ export class ValidationExecutor {
             validationError.value = value;
         validationError.property = propertyName;
         validationError.children = [];
-        validationError.constraints = {};
+        validationError.constraints = [];
         return validationError;
     }
     conditionalValidations(object, value, metadatas) {
@@ -181,7 +178,7 @@ export class ValidationExecutor {
                         const promise = validatedValue.then(isValid => {
                             if (!isValid) {
                                 const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
-                                error.constraints[type] = message;
+                                error.constraints.push(message);
                                 if (metadata.context) {
                                     if (!error.contexts) {
                                         error.contexts = {};
@@ -195,7 +192,7 @@ export class ValidationExecutor {
                     else {
                         if (!validatedValue) {
                             const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
-                            error.constraints[type] = message;
+                            error.constraints.push(message);
                         }
                     }
                     return;
@@ -215,7 +212,7 @@ export class ValidationExecutor {
                         const validationResult = flatValidatedValues.every((isValid) => isValid);
                         if (!validationResult) {
                             const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
-                            error.constraints[type] = message;
+                            error.constraints.push(message);
                             if (metadata.context) {
                                 if (!error.contexts) {
                                     error.contexts = {};
@@ -230,7 +227,7 @@ export class ValidationExecutor {
                 const validationResult = validatedSubValues.every((isValid) => isValid);
                 if (!validationResult) {
                     const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
-                    error.constraints[type] = message;
+                    error.constraints.push(message);
                 }
             });
         });
@@ -261,32 +258,11 @@ export class ValidationExecutor {
                 error.property = metadata.propertyName;
                 error.target = metadata.target;
                 const [type, message] = this.createValidationError(metadata.target, value, metadata);
-                error.constraints = {
-                    [type]: message
-                };
+                error.constraints = [message];
                 errors.push(error);
             }
         });
     }
-    mapContexts(object, value, metadatas, error) {
-        return metadatas
-            .forEach(metadata => {
-            if (metadata.context) {
-                let customConstraint;
-                if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {
-                    const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);
-                    customConstraint = customConstraints[0];
-                }
-                const type = this.getConstraintType(metadata, customConstraint);
-                if (error.constraints[type]) {
-                    if (!error.contexts) {
-                        error.contexts = {};
-                    }
-                    error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);
-                }
-            }
-        });
-    }
     createValidationError(object, value, metadata, customValidatorMetadata) {
         const targetName = object.constructor ? object.constructor.name : undefined;
         const type = this.getConstraintType(metadata, customValidatorMetadata);
diff --git a/node_modules/class-validator/esm2015/validation/ValidationExecutor.js.map b/node_modules/class-validator/esm2015/validation/ValidationExecutor.js.map
index a2f9494..5b4c0c2 100644
--- a/node_modules/class-validator/esm2015/validation/ValidationExecutor.js.map
+++ b/node_modules/class-validator/esm2015/validation/ValidationExecutor.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/validation/ValidationExecutor.ts"],"names":[],"mappings":"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","file":"ValidationExecutor.js","sourcesContent":["import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n"],"sourceRoot":".."}
\ No newline at end of file
+{"version":3,"sources":["../../src/validation/ValidationExecutor.ts"],"names":[],"mappings":"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","file":"ValidationExecutor.js","sourcesContent":["import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = [\"an unknown value was passed to the validate function\"];\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = [`property ${property} should not exist`];\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (error.constraints.length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = [];\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints.push(message);\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints.push(message);\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = [message];\n                errors.push(error);\n            }\n        });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n"],"sourceRoot":".."}
\ No newline at end of file
diff --git a/node_modules/class-validator/esm5/validation/ValidationError.js.map b/node_modules/class-validator/esm5/validation/ValidationError.js.map
index b72b050..81cd4bb 100644
--- a/node_modules/class-validator/esm5/validation/ValidationError.js.map
+++ b/node_modules/class-validator/esm5/validation/ValidationError.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/validation/ValidationError.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH;IAAA;IAuEA,CAAC;IA9BG;;;;;OAKG;IACH,kCAAQ,GAAR,UAAS,cAA+B,EAAE,SAA0B,EAAE,UAAuB;QAA7F,iBAuBC;QAvBQ,+BAAA,EAAA,sBAA+B;QAAE,0BAAA,EAAA,iBAA0B;QAAE,2BAAA,EAAA,eAAuB;QACzF,IAAM,SAAS,GAAG,cAAc,CAAC,CAAC,CAAC,WAAS,CAAC,CAAC,CAAC,EAAE,CAAC;QAClD,IAAM,OAAO,GAAG,cAAc,CAAC,CAAC,CAAC,YAAU,CAAC,CAAC,CAAC,EAAE,CAAC;QACjD,IAAM,oBAAoB,GAAG,UAAC,YAAoB,IAAa,OAAA,iBAAe,SAAS,GAAG,UAAU,GAAG,YAAY,GAAG,OAAO,+CAA0C,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,KAAI,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,OAAO,QAAK,EAA3K,CAA2K,CAAC;QAE3O,IAAI,CAAC,SAAS,EAAE;YACZ,OAAO,oBAAkB,SAAS,IAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,IAAG,OAAO,kCAA+B;gBAClI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC7D,IAAI,CAAC,QAAQ;qBACR,GAAG,CAAC,UAAA,UAAU,IAAI,OAAA,UAAU,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,KAAI,CAAC,QAAQ,CAAC,EAAxD,CAAwD,CAAC;qBAC3E,IAAI,CAAC,EAAE,CAAC,CAAC;SACrB;aAAM;YACH,6DAA6D;YAC7D,IAAM,mBAAiB,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAI,IAAI,CAAC,QAAQ,MAAG,CAAC,CAAC,CAAC,MAAG,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,IAAG,IAAI,CAAC,QAAU,CAAC;YAE/H,IAAI,IAAI,CAAC,WAAW,EAAE;gBAClB,OAAO,oBAAoB,CAAC,mBAAiB,CAAC,CAAC;aAClD;iBAAM;gBACH,OAAO,IAAI,CAAC,QAAQ;qBACf,GAAG,CAAC,UAAA,UAAU,IAAI,OAAA,UAAU,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,KAAG,UAAU,GAAG,mBAAmB,CAAG,EAAhF,CAAgF,CAAC;qBACnG,IAAI,CAAC,EAAE,CAAC,CAAC;aACjB;SACJ;IACL,CAAC;IACL,sBAAC;AAAD,CAvEA,AAuEC,IAAA","file":"ValidationError.js","sourcesContent":["/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n"],"sourceRoot":".."}
\ No newline at end of file
+{"version":3,"sources":["../../src/validation/ValidationError.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH;IAAA;IAqEA,CAAC;IA9BG;;;;;OAKG;IACH,kCAAQ,GAAR,UAAS,cAA+B,EAAE,SAA0B,EAAE,UAAuB;QAA7F,iBAuBC;QAvBQ,+BAAA,EAAA,sBAA+B;QAAE,0BAAA,EAAA,iBAA0B;QAAE,2BAAA,EAAA,eAAuB;QACzF,IAAM,SAAS,GAAG,cAAc,CAAC,CAAC,CAAC,WAAS,CAAC,CAAC,CAAC,EAAE,CAAC;QAClD,IAAM,OAAO,GAAG,cAAc,CAAC,CAAC,CAAC,YAAU,CAAC,CAAC,CAAC,EAAE,CAAC;QACjD,IAAM,oBAAoB,GAAG,UAAC,YAAoB,IAAa,OAAA,iBAAe,SAAS,GAAG,UAAU,GAAG,YAAY,GAAG,OAAO,+CAA0C,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,KAAI,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,OAAO,QAAK,EAA3K,CAA2K,CAAC;QAE3O,IAAI,CAAC,SAAS,EAAE;YACZ,OAAO,oBAAkB,SAAS,IAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,IAAG,OAAO,kCAA+B;gBAClI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC7D,IAAI,CAAC,QAAQ;qBACR,GAAG,CAAC,UAAA,UAAU,IAAI,OAAA,UAAU,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,KAAI,CAAC,QAAQ,CAAC,EAAxD,CAAwD,CAAC;qBAC3E,IAAI,CAAC,EAAE,CAAC,CAAC;SACrB;aAAM;YACH,6DAA6D;YAC7D,IAAM,mBAAiB,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAI,IAAI,CAAC,QAAQ,MAAG,CAAC,CAAC,CAAC,MAAG,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,IAAG,IAAI,CAAC,QAAU,CAAC;YAE/H,IAAI,IAAI,CAAC,WAAW,EAAE;gBAClB,OAAO,oBAAoB,CAAC,mBAAiB,CAAC,CAAC;aAClD;iBAAM;gBACH,OAAO,IAAI,CAAC,QAAQ;qBACf,GAAG,CAAC,UAAA,UAAU,IAAI,OAAA,UAAU,CAAC,QAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,KAAG,UAAU,GAAG,mBAAmB,CAAG,EAAhF,CAAgF,CAAC;qBACnG,IAAI,CAAC,EAAE,CAAC,CAAC;aACjB;SACJ;IACL,CAAC;IACL,sBAAC;AAAD,CArEA,AAqEC,IAAA","file":"ValidationError.js","sourcesContent":["/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: string[];\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n"],"sourceRoot":".."}
\ No newline at end of file
diff --git a/node_modules/class-validator/esm5/validation/ValidationExecutor.js b/node_modules/class-validator/esm5/validation/ValidationExecutor.js
index efdc2ec..c6eb963 100644
--- a/node_modules/class-validator/esm5/validation/ValidationExecutor.js
+++ b/node_modules/class-validator/esm5/validation/ValidationExecutor.js
@@ -50,7 +50,7 @@ var ValidationExecutor = /** @class */ (function () {
             validationError.value = undefined;
             validationError.property = undefined;
             validationError.children = [];
-            validationError.constraints = { unknownValue: "an unknown value was passed to the validate function" };
+            validationError.constraints = ["an unknown value was passed to the validate function"];
             validationErrors.push(validationError);
             return;
         }
@@ -83,9 +83,8 @@ var ValidationExecutor = /** @class */ (function () {
             if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {
                 // throw errors
                 notAllowedProperties.forEach(function (property) {
-                    var _a;
                     var validationError = _this.generateValidationError(object, object[property], property);
-                    validationError.constraints = (_a = {}, _a[ValidationTypes.WHITELIST] = "property " + property + " should not exist", _a);
+                    validationError.constraints = ["property " + property + " should not exist"];
                     validationError.children = undefined;
                     validationErrors.push(validationError);
                 });
@@ -102,7 +101,7 @@ var ValidationExecutor = /** @class */ (function () {
             if (error.children) {
                 error.children = _this.stripEmptyErrors(error.children);
             }
-            if (Object.keys(error.constraints).length === 0) {
+            if (error.constraints.length === 0) {
                 if (error.children.length === 0) {
                     return false;
                 }
@@ -128,7 +127,6 @@ var ValidationExecutor = /** @class */ (function () {
         }
         // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not
         this.customValidations(object, value, definedMetadatas, validationError);
-        this.mapContexts(object, value, definedMetadatas, validationError);
         if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {
             return;
         }
@@ -140,8 +138,6 @@ var ValidationExecutor = /** @class */ (function () {
         }
         this.customValidations(object, value, customValidationMetadatas, validationError);
         this.nestedValidations(value, nestedValidationMetadatas, validationError.children);
-        this.mapContexts(object, value, metadatas, validationError);
-        this.mapContexts(object, value, customValidationMetadatas, validationError);
     };
     ValidationExecutor.prototype.generateValidationError = function (object, value, propertyName) {
         var validationError = new ValidationError();
@@ -157,7 +153,7 @@ var ValidationExecutor = /** @class */ (function () {
             validationError.value = value;
         validationError.property = propertyName;
         validationError.children = [];
-        validationError.constraints = {};
+        validationError.constraints = [];
         return validationError;
     };
     ValidationExecutor.prototype.conditionalValidations = function (object, value, metadatas) {
@@ -186,7 +182,7 @@ var ValidationExecutor = /** @class */ (function () {
                         var promise = validatedValue.then(function (isValid) {
                             if (!isValid) {
                                 var _a = _this.createValidationError(object, value, metadata, customConstraintMetadata), type = _a[0], message = _a[1];
-                                error.constraints[type] = message;
+                                error.constraints.push(message);
                                 if (metadata.context) {
                                     if (!error.contexts) {
                                         error.contexts = {};
@@ -200,7 +196,7 @@ var ValidationExecutor = /** @class */ (function () {
                     else {
                         if (!validatedValue) {
                             var _a = _this.createValidationError(object, value, metadata, customConstraintMetadata), type = _a[0], message = _a[1];
-                            error.constraints[type] = message;
+                            error.constraints.push(message);
                         }
                     }
                     return;
@@ -220,7 +216,7 @@ var ValidationExecutor = /** @class */ (function () {
                         var validationResult = flatValidatedValues.every(function (isValid) { return isValid; });
                         if (!validationResult) {
                             var _a = _this.createValidationError(object, value, metadata, customConstraintMetadata), type = _a[0], message = _a[1];
-                            error.constraints[type] = message;
+                            error.constraints.push(message);
                             if (metadata.context) {
                                 if (!error.contexts) {
                                     error.contexts = {};
@@ -235,7 +231,7 @@ var ValidationExecutor = /** @class */ (function () {
                 var validationResult = validatedSubValues.every(function (isValid) { return isValid; });
                 if (!validationResult) {
                     var _b = _this.createValidationError(object, value, metadata, customConstraintMetadata), type = _b[0], message = _b[1];
-                    error.constraints[type] = message;
+                    error.constraints.push(message);
                 }
             });
         });
@@ -246,7 +242,6 @@ var ValidationExecutor = /** @class */ (function () {
             return;
         }
         metadatas.forEach(function (metadata) {
-            var _a;
             if (metadata.type !== ValidationTypes.NESTED_VALIDATION &&
                 metadata.type !== ValidationTypes.PROMISE_VALIDATION) {
                 return;
@@ -267,34 +262,12 @@ var ValidationExecutor = /** @class */ (function () {
                 error.value = value;
                 error.property = metadata.propertyName;
                 error.target = metadata.target;
-                var _b = _this.createValidationError(metadata.target, value, metadata), type = _b[0], message = _b[1];
-                error.constraints = (_a = {},
-                    _a[type] = message,
-                    _a);
+                var _a = _this.createValidationError(metadata.target, value, metadata), type = _a[0], message = _a[1];
+                error.constraints = [message];
                 errors.push(error);
             }
         });
     };
-    ValidationExecutor.prototype.mapContexts = function (object, value, metadatas, error) {
-        var _this = this;
-        return metadatas
-            .forEach(function (metadata) {
-            if (metadata.context) {
-                var customConstraint = void 0;
-                if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {
-                    var customConstraints = _this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);
-                    customConstraint = customConstraints[0];
-                }
-                var type = _this.getConstraintType(metadata, customConstraint);
-                if (error.constraints[type]) {
-                    if (!error.contexts) {
-                        error.contexts = {};
-                    }
-                    error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);
-                }
-            }
-        });
-    };
     ValidationExecutor.prototype.createValidationError = function (object, value, metadata, customValidatorMetadata) {
         var targetName = object.constructor ? object.constructor.name : undefined;
         var type = this.getConstraintType(metadata, customValidatorMetadata);
diff --git a/node_modules/class-validator/esm5/validation/ValidationExecutor.js.map b/node_modules/class-validator/esm5/validation/ValidationExecutor.js.map
index 968a8ab..4109263 100644
--- a/node_modules/class-validator/esm5/validation/ValidationExecutor.js.map
+++ b/node_modules/class-validator/esm5/validation/ValidationExecutor.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/validation/ValidationExecutor.ts"],"names":[],"mappings":"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","file":"ValidationExecutor.js","sourcesContent":["import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n"],"sourceRoot":".."}
\ No newline at end of file
+{"version":3,"sources":["../../src/validation/ValidationExecutor.ts"],"names":[],"mappings":"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","file":"ValidationExecutor.js","sourcesContent":["import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = [\"an unknown value was passed to the validate function\"];\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = [`property ${property} should not exist`];\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (error.constraints.length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = [];\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints.push(message);\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints.push(message);\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints.push(message);\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = [message];\n                errors.push(error);\n            }\n        });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n"],"sourceRoot":".."}
\ No newline at end of file
diff --git a/node_modules/class-validator/types/validation/ValidationError.d.ts b/node_modules/class-validator/types/validation/ValidationError.d.ts
index 3ebaea5..e5fba52 100644
--- a/node_modules/class-validator/types/validation/ValidationError.d.ts
+++ b/node_modules/class-validator/types/validation/ValidationError.d.ts
@@ -21,9 +21,7 @@ export declare class ValidationError {
     /**
      * Constraints that failed validation with error messages.
      */
-    constraints?: {
-        [type: string]: string;
-    };
+    constraints?: string[];
     /**
      * Contains all nested validation errors of the property.
      */
diff --git a/node_modules/class-validator/types/validation/ValidationExecutor.d.ts b/node_modules/class-validator/types/validation/ValidationExecutor.d.ts
index 4cbe1a6..83f4c81 100644
--- a/node_modules/class-validator/types/validation/ValidationExecutor.d.ts
+++ b/node_modules/class-validator/types/validation/ValidationExecutor.d.ts
@@ -22,7 +22,6 @@ export declare class ValidationExecutor {
     private conditionalValidations;
     private customValidations;
     private nestedValidations;
-    private mapContexts;
     private createValidationError;
     private getConstraintType;
 }
